--no-vector





gensym symbole (beginnend mit #:) sollten beim symbol-printen NICHT in || gesteckt werden
derzeit wird irgendwie gemischt, es gibt mit und ohne ||:
JMurmel> (pprint (macroexpand-1 '(dogenerator (x (scan-multiple (scan '(11 22 33 44)) (scan #(111 222 333)) (scan 1 1 5)) 1 2 3 'done) (writeln x))))
(let
   ((#:g25 (scan-multiple (scan (quote (11 22 33 44))) (scan #(111 222 333)) (scan 1 1 5))))
   (labels
      ((#:g26 (x #:g24) (when #:g24 (writeln x) (multiple-value-call #:g26 (#:g25)))))
      (multiple-value-call |#:g26| (|#:g25|))
      (let ((x nil))
         1
         2
         3
         (quote done))))
==> t

-> eigentlich sollte LambdaJSymbol ein attribut haben interned/uninterned
   gensym sollte namen im sinne g123 vergeben, nicht #:g123
   LabmdaJSymbol.printSEx() sollte bei "escapeAtoms=true" bei uninterned "#:" voranstellen
   es sollte ein readermacro #: geben, das das folgende als uninterned symbol einliest


im else zweig kann man nil weglassen. sollte man auch weglassen weil sonst gibts umsonst den environment lookup von nil
-> oder in expand wegoptimieren

   cond mit nur zwei zweigen: condition + t
   -> in if umwandeln, kann ggf weiter optimiert werden
      (cond ((null x) 'null)
            (t 'notnull))

      (if (null x) 'null
        'notnull)

      (if x 'notnull
        'null)

mangle könnte einfachere namen generieren, wenn häufige buchstaben nicht durch zahlen ersetzt werden
  -     _dash_
  %     _pc_

assq und assoc: checken ob branchless was bringt: nullcheck & car-vergleich

kompilierte defuns vielleicht anders ausspucken:
  statt define_... mit einem lambda -> java methode + zuweisung zur globalen variable inline emittieren
  dann würden zumindest für die toplevel defuns lesbare namen im JFR stehen

http://cs-www.cs.yale.edu/homes/dvm/format-stinks.html
-> macro "out" als alternative zu format

vector-ensure-capacity, vector-trim-to-size
-> fehler für simple vectors

vector-capacity: gibt length für simple vector, capacity für stringbuffer/builder
-> geht nicht weil arraylist gibt capacity nicht her
   -> geht evtl mit reflection, k.a. obs da add-opens braucht

mlib: foldl, foldr, vielleicht foreach, filter

checken was alles serializable sein sollte, Closure wsl. nicht

toplevel let/let*/letrec (nicht named) gesondert behandeln: {} block mit normalen Java variablen
-> damit würden defuns und lambdas mit nur einem toplevel letXX effizienter
-> ggf doch topelevel named letXX in einen loop kompilieren?

vielleicht loc aufteilen: String filename, int linepos int colpos, String info
-> bei (declaim (optimize (debug 0))) bleibt info leer, würde eine menge stringliterale einsparen


- vielleicht Callable, Runnable, Supplier, Consumer, ... ins Murmel Typsystem einhängen? functionp + eval + compiler-runtime

- vielleicht deque integrieren (java.util.ArrayDeque)?
  von vector erben, oder alleinstehender typ?
- splice integrieren?


mlib - scan: weitere helper

(scan-tree lst)... liefert einen generator der ein depth first traversal macht und die blaetter liefert

(scan-if generator pred)... filtern
-> oder "filter" ? oder remove-if erweitern?
   -> (filter-generator pred generator), vgl. (remove-if-not pred seq)

(map-generator func generator . more-generators)... aufeinanderfolgende calls des erzeugten generators liefern (function (generator)),
                                                    ähnlich wie map, return ist aber generator statt sequence
-> brauchts das oder ist das (multiple-value-compose function generator) ?
   -> bei multiple-value-compose muss man selber den secondary value durchreichen, und ggf. bei nil nix machen
      wär also schon gut. eine function als parameter reicht, weil (scan-mapped generator (compose f3 f2 f1)) geht auch
-> oder "transduce-generator" ?
   -> transduce könnte eine funktion value...->value,more übernehmen. damit könnte transduce die funktionen map und filter umsetzen

(flatmap-generator func generator . more-generators)
-> func übernimmt soviele parameter wie generators gegeben sind, liefert einen generator
   flatmap liefert einen generator, der die concatenation liefert

(reduce-generator func generator)
(count-generator generator)... liefert ein fixnum. oder soll length erweitert werden dass generator auch geht? oder beides? 
(collect-generator generator result-type)... materialisiert in eine liste/ vector/ bitvector/ string
-> oder (concatenate-generator result-type generator . more-generators) -> sequence, vgl CL concatenate

oder überhaupt generator ("lazy sequence") überall zulassen wo sequence erlaubt ist?
-> map, reduce, reverse (?), remove, remove-if, length könnten generators unterstützen
   -> map müsste 'generator als zus. returntyp unterstützen, filter/remove/remove-if würde bei input generator einen generator liefern
      -> terminals count/length, collect/concatenate, reduce: CL funktion kann erweitert werden dass generator als parameter zulässig ist, achtung: from-end-p bei reduce
         reverse: CL funktionen besser ohne generator support belassen, weil das geht nicht lazy, es müsste zu beginn alles materialisiert werden

oder: filter, foldl, foldr (wie Scheme): übernehmen list, vector, bitvector, string und generator
-> (foldl (lambda (l r) (cons r l) nil gen) würde eine liste ergeben
   (foldr cons nil gen) eine verkehrte liste



Clojure hat swap!, z.B. (swap! i + 3)
-> das könnte +f, -f, *f, /f usw. ersetzen. der name swap! scheint eher ungünstig. Clojure swap! scheint ausserdem atomic zu sein

Scheme hat case-lambda

primitive und compilerprimitive könnten dasselbe sein, bzw. die interpreter primitives könnten CompilerPrimitive implementieren
-> ausser: apply (und eval?)
-> aber: der interpreter hat die liste mit argumenten bereits (vom reader), das müsste bei jedem call in ein array verwandelt werden
   -> besser primitive und compilerprimitive beide beibehalten
   -> aber: der interpreter hat NICHT die liste mit argumenten, die wird von evlis erzeugt, und evlis (oder ein zusätzliches evlis) könnte auch ein array erzeugen

evalOpencode vervollständigen
-> und environment() könnte alle primitives generieren: loop über WellknownSymbol.values + argcountcheck + evalOpencode
-> evtl ALLES an die WellknownSymbols dranhängen?
   argcount min/max
   code für Primitive
   code für CompilerPrimitive: für getValue() in MurmelJavaProgram benutzen
   zuordnung name/ compiler-javaname für emitOpencode im compiler


nth, nthcdr von mlib nach murmel? wg. ArraySlice und string (?)
vielleicht make-array aus murmel rauskicken und in mlib umsetzen
-> in jmurmel nur make-simple-vector, make-simple-bitvector, ...


vielleicht die cons-zählerei rauskicken? braucht eh niemand
-> oder zumindest static zähler
-> evtl auch maxEnvLen, maxEvalStack, maxEvalLevel, oder vielleicht besser diese zähler in ein DTO stecken, das optional allokiert wird

static final members können aus system properties initialisiert werden
-> evtl. für Tracelevel LambdaJ.trace verwenden, dann würde ggf. JIT das gance tracing wegoptimieren. traceOn & traceFunc wäre ggf auch hinfällig

statt CustomEnvironmentSupplier -> builder pattern, siehe todo_dont.txt
-> CustomEnvironment bei jedem aufruf von interpretExpressions() mitzugeben ist eh fragwürdig.
   init() jedesmal aufrufen eigentlich auch, weil das ändert die members topEnv, lispStdin, lispStdout, nicht schön!

 

clojure hat "named lambda": (fn label [params] forms)
-> vielleicht "named lambda" in Murmel? label würd aber dasselbe machen
-> ausser: Clojure generiert für ein named lambda eine wirkliche funktion, gibt dann bessere stacktraces
   in murmel wäre ggf. der output von JMC besser lesbar (weniger anonyme funktionen). closures gibts dann aber nicht mehr gratis

beim iterieren kann man das listenende mit "endp" checken, endp sollte einen fehler werfen wenn cdr kein cons und nicht nil ist (d.h. fehler bei dotted list)
-> oder mit "atom" checken, das geht schneller, dotted lists bleiben aber unerkannt, letztes element einer dotted list bleibt unerkannt/ wird ignoriert


JFFI: wie soll man variadic methods aufrufen, z.B.
-> ((jmethod "java.util.Arrays" "asList" "[Ljava.lang.Object;") 1) -> #(1)
-> ((jmethod "java.util.Arrays" "asList" "[Ljava.lang.Object;")) -> Error: asList: expected one argument but no argument was given
-> ((jmethod "java.util.Arrays" "asList" "[Ljava.lang.Object;") 1 2 3) -> Error: asList: expected one argument but got extra arg(s) nil

-> sollte kompiliertes catch und/ oder throw TCO bekommen?
-> interpreter + compiler:  (error 'control-error) falls es ein throw tag nicht gibt, braucht man wsl nicht für ein fertiges programm, aber fürs interaktive entwickeln


https://docs.oracle.com/en/java/javase/17/vm/class-data-sharing.html
-> vielleicht ein massgeschneidertes classes.jsa für das dockerimage erzeugen?


performance impact von assert: https://stackoverflow.com/questions/4624919/performance-drag-of-java-assertions-when-disabled/40919125#40919125

(let loop ((n 10)) (writeln n) (if (= n 3) (setq loop (lambda (n) (writeln (quote done))))) (loop (1- n)))
-> geht im interpreter, gibt java compile fehler im compiler (cannot assign a value to final variable _loop2)
(labels ((l () (writeln 'vorher) (setq l (lambda () (writeln 'nachher))))) (l) (l))
-> geht im interpreter, gibt java compile fehler im compiler (cannot assign a value to final variable _l2)
-> in sbcl können lokale funktionen mit setq auch nicht verändert werden (local call vs. full call), dafür fallen runtime argcount checks usw weg
-> murmel sollte setq mit loop labels und labels-lokalen funktionen verweigern, dann könnten argcount checks 1x gemacht werden, ggf. könnte der environment lookup wegfallen
   -> vielleicht sollte expandForm() ein environment mit lokalen funktionen (und primitivies?) mitführen, mit symbol->parameteranzahl tupeln.
      damit könnte zuweisung an locals (und bei speed>=1 an primitives) erkannt und verweigert werden, und argcount checks könnte 1x in expandForm() gemacht werden.
      1x argcount check wär für interpreter und compiler nützlich, und ggf. wäre auch notAPrimitive() im compiler hinfällig und/ oder interpreter und compiler würden sich gleich verhalten


(defmacro m() 1)
(eval '(m))
-> geht im interpreter, geht nicht im compiler, weil m müsste zur laufzeit aufgelöst werden

(defmacro x nil 1)
(labels ((x (y) 11))
  (x)) ; sbcl ruft die lokale funktion auf (mit fehler wg. argument), Murmel ruft das makro
-> ggf. angleichen oder mit fehler verweigern
-> macros sollten wsl auch scope bekommen

System.err vs. System.out aufräumen: repl sollte alles nach System.out schreiben, !repl sollte fehler nach System.err schreiben


eval-when endlich einbauen
siehe CLHS "Special Operator EVAL-WHEN" http://clhs.lisp.se/Body/s_eval_w.htm
siehe CLHS "3.2.3.1 Processing of Top Level Forms" http://www.lispworks.com/documentation/lw60/CLHS/Body/03_bca.htm
siehe CLtL "5.3.3. Control of Time of Evaluation" https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node68.html
-> vielleicht test dazunehmen? wie?

-> (eval-when (compile | load | compile load) forms...)
   nur toplevel, CL hat noch "eval/ :execute", das brauchts eigentlich nur für non-toplevel eval-when
-> "nur toplevel" heisst, eval-when kann auch in einem progn und/ oder einem anderen eval-toplevel drinstehen

-> (load): "not-compile-time"  (das ist das neue default)
   interpreter: enthaltene defmacro wird verarbeitet, andere forms werden verarbeitet -> so wie bisher
   compiler:    enthaltene defmacro wird verarbeitet, andere forms werden nur compiliert -> anders als bisher wird nur defmacro in den compiletime-interpreter gesteckt

   (compile load): "compile-time-too"
   interpreter: enthaltene defmacro wird verarbeitet, andere forms werden verarbeitet -> so wie bisher
   compiler:    enthaltene defmacro wird verarbeitet, andere forms werden in den interpreter gesteckt und compiliert
   -> mit (eval-when (compile load) ...) kann man das bisherige verhalten einstellen. wirds für mlib brauchen. in diesem modus steht auch im compiler alles zum macroschreiben zur verfügung

   (compile): "compile-time-only"
   interpreter: enthaltene forms werden ignoriert, ergebnis von eval-when ist nil
   compiler:    enthaltene defmacro wird verarbeitet, andere forms werden nur in den compiletime-interpreter gesteckt
   -> effektiv kann man mit diesem modus wohl compiler macros machen: die makros werden nur beim kompilieren expandiert, und die makros haben funktionen aus diesem modus zur verfügung

   ()
   interpreter: enthaltene forms werden ignoriert
   compiler: enthaltene forms werden ignoriert

-> zulässige übergänge (toplevel eval-when oder nested eval-when innerhalb progn oder eval-when)
   (compile load) "compile-time-too": wegnehmen ist erlaubt
   (load) "not-compile-time": load wegnehmen ist erlaubt (aber nicht sinnvoll), compile dazugeben ist erlaubt
   (compile): wegnehmen ist erlaubt (aber nicht sinnvoll), dazugeben wird ignoriert (oder fehler oder warning?)
   (): wegnehmen kamma nix mehr, dazugeben wird ignoriert


zusammenspiel compiler/interpreter bzgl. values reparieren, und *features*

packed-list könnte ein ArraySlice liefern. wie list, aber weniger allokationen, nth und nthcdr wäre schnell wenns in JMurmel drin wäre, cdr würde allokieren, rplacd geht nicht



mit java.util.concurrent.locks.ReentrantLock kann man synchronized nachbasteln



evlis könnte symbole durch eine environmententry referenz ersetzen:
-> evlis schaut beim iterieren: ist es ein symbol, wenn ja sucht evlis 1x mit assq die conscell im environment, und ersetzt das symbol durch (envref enventry)
   die neue "special form" envref muss in eval eingebaut werden, und setq muss auch erweitert werden/ damit umgehen können, weil dann kann "(setq (envref enventry) value)" vorkommen
-> der ganze spass würde auch für makros gehen: evlis ersetzt einen macrocall durch die expansion
-> ggf. kann man auch lineinfo in die erzeugten conscells aus dem macro aufruf reinkopieren?

-> in evlis UND beim abarbeiten einer function application expandieren/ ersetzen
-> envref für freie variablen, paramref für parameter: paramref enthält einen offset, und gelesen wird mit (cdr (nth env offset)) oder so
   envref geht nicht für parameter weil da würden die argumente des ersten aufrufs hart verdrahtet

statt dem "opencoden" im interpreter könnte ähnlich wie tryExpand gecheckt werden, ob das car der form ein symbol das auf eine primitive zeigt. (muss aber vor evlis call passieren)
 falls ja wird das car durch ein nicht internes symbol "prim-application" ersetzt und danach die adresse der primitive reingezwickt.
 z.b. (car 1 2) -> (prim-application #<car> 1 2). "prim-application" kommt in den switch mit den special forms, ist also auch eine special form, die
 in der sprache aber nicht sichtbar ist weil nicht interned. diese neue "hidden special form" macht evlis und ruft dann die primitive auf.
 -> darf nur bei speed >= 1 gemacht werden, weil sonst könnte sich das ändern, was hinter dem jeweiligen symbol liegt (bei speed=0 können auch primitives mit setq geändert werden)
    -> ist aber doch eine änderung zu bisher, weil derzeit kann auch bei primitives ein macro davorschalten
 -> evalOpencode brauchts dann nicht mehr, und der switch in opencode fällt weg
 -> wenns einmal umgepatcht ist, werden primitive-aufrufe immer gleich im ersten switch behandelt, keine ifs, kein checken obs ein macro ist
 -> optimierung wär auch noch möglich: (cdr (cdr x)) -> (prim-application #<cddr> x) oder (prim-application #<nthcdr> 2 x), wobei #<cddr> nicht im environment drin ist, symbol dazu brauchts auch keines

evalLet() macht jedesmal ziemlich viele checks inkl HashMap und member
-> tryExpand könnte 1x checken, old style (let (a b c) ...) -> (let ((a nil) (b nil) (c nil)) ...) umschreiben, dann wär evalLet viel einfacher und schneller
-> generelles problem ist, dass tryExpand topLevel forms nicht sieht
   -> umbauen dass tryexpand nicht forms(-liste) bekommt und forms.rplaca macht, sondern die form bekommt und inplace modifiziert: car und cdr austauscht

??? ähnlich könnte man CPS on-the-fly machen: eine neue special form, die bekommt als zusätzlichen parameter die "next" funktion. nach abarbeiten der aktuellen forms gehts mit "continue tailcall"
dorthin. 

der trick mit nicht-internden symbolen müsste für "hidden special forms" aber auch für "jmurmel interne primitives" gehen.


zip einen zusätzlichen parameter "append-to" geben, damit könnte man bei tailcalls ConsCells wiederbenutzen. bei "let loop" gibts viele tailcalls, das müsste die churn rate runtersetzen
ähnliches müsste im compiler auch gehen: statt einen call mit argumenten und commas:
-> tailcall(f, reassign3(args, v1, v2, v3)) oder
   tailcall(f, reassign1(args, v1) usw.
   oder gleich tailcall3(f, args, v1, v2, v3) - wenn args zufällig die passende länge hat, wird wiederbenutzt, sonst wird ein neues array allokiert
   -> ist aber kompliziert, wsl. ist allokieren+gc schneller als diese komplizierte logik


import könnte alle public methoden einer java klasse ::-en, vielleicht ein optionales präfix als argument für import?
und/ oder eine funktion (z.B. "reflect"), die eine liste mit :: forms ausspuckt, und define erweitern dass nicht nur symbol/value sondern auch eine liste geht?
-> reflect könnte auch optional eine liste mit strings bekommen, die enthält die gewünschten methoden (statt alle)
-> vielleicht auch getter/ setter generieren für members? nur setter falls nicht final?
-> vielleicht auch MurmelProgram akzeptieren, ggf. iwie speziell behandeln? vielleicht import für MurmelProgram, reflect für normale Java klassen? oder MurmelProgram in load/ require einbauen?
-> load und require sollten auch jar files mit kompiliertem murmel können
   dazu sollte die java methode loadfile erweitert werden, die wird von allen benutzt, interpreter und compiler.
   MurmelJavaProgram könnte weitere reflection methoden bekommen (getAllFunctions(), getAllValues()=, die von loadFile
   genutzt werden können, um das aktuelle interpreter- und/ oder compiler environment zu erweitern.
   der compiler könnte members für alle importierten methoden generieren, oder nur einen member vom typ Object[],
   und die environmenteinträge zeigen dann mit fixen indizes in dieses array:
     statt "write" -> rt()::_write (das gilt in der form eh nur für vordef prim)
     oder  "pi" -> "_pi"
       ->  "imported-name2" -> modulname[2]
     das würd eher einfach gehen, wenn murmelprogram zwei arrays liefert: eins mit den namen, eins mit den werten. oder ein 2dim array mit name/wert tupeln.
     sollte beim importieren ein neues array mit kopien der werte gemacht werden? soll ein importierendes modul die globals des importierten moduls ändern können?
     -> wsl keine kopie, beim bisherigen load bzw. require kann auch jeder alles ändern. hiesse dann: 2 arrays, eins mit namen wird zum erzeugen der environmenteinträge verwendet,
        das andere wird mittels des neuen member referenziert.
        obiges würd für compiler funktionieren. vielleicht muss es auch zusätzlich oder stattdessen ein array mit enventries (oder eine alist?) für den interpreter geben?
        oder müssen compiler und interpreter gar nicht synchron laufen, weil eval sieht nur "predef topenv" + das was als argument mitgegeben wird?

funktionen symbol->string und string->symbol, wobei symbol->string ist symbol-name, und string->symbol ist make-symbol
und (intern symbol) -> interned-symbol
-> vielleicht doch endlich umstellen, dass der reader lc/ uc/ nix macht (mit befehlszeilenoption?), und stringvergleiche case sensitiv sind?!!!!!
   -> bei case-insensitiven stringvergleichen gäbe es potenziell gefährliche unterschiede zu CL: in CL ist (intern (make-symbol "AaA")) != aaa, in Murmel wäre das das gleiche symbol


macht ein macro with-iterator sinn (für Java iterator)?, siehe auch http://clhs.lisp.se/Body/m_w_hash.htm

safety könnte werden:
3 wie bisher alles checken
2 es kann CLassCastExceptions geben statt error
1 es kann saturating overflow geben
0 es kann wraparound overflow geben

nthcdr und nth sollten ggf. von mlib nach murmel wg. ArraySlice, und wg. Strings
-> besser (elt sequence index), http://www.lispworks.com/documentation/HyperSpec/Body/f_elt.htm

funktion die den awt frame eines turtleframe liefert, für java interop

:: könnte statt nur strings auch symbols schlucken:
-> (:: java.lang.System currentTimeMillis)
   -> nein, geht so nicht weil :: ist keine special form, der versuch, die symbols aufzulösen gibt fehler
      -> symbols wären trotzdem sinnvoll, dann könnt man ein macro basteln das quoted, und/ oder ein macro, das aus klasse, methode und einer plist mit typ/wert
         einen call bastelt (bei instanzmethoden müsste die plist wohl mit "this" <objekt> beginnen)
         oder alist statt plist? -> egal, plist ist weniger tipparbeit



dpans3 steht für "Common Lisp ANSI draft 3", das war der Input für AnsiCL
siehe https://www.reddit.com/r/lisp/comments/5xncjo/is_there_a_lispy_clhs_anywhere/ für eine diskussion re: Lizenz
TeX Sources (frei) gibts:
http://www.cs.cmu.edu/Groups//AI/lang/lisp/doc/standard/ansi/dpans/
https://github.com/xach/dpans
https://github.com/antoszka/dpANS3

Is there a straightforward lisp equivalent of Python's generators?
-> https://stackoverflow.com/questions/32956033/is-there-a-straightforward-lisp-equivalent-of-pythons-generators


letrec im compiler ist fishy, laut langref sollten folgende variablen undefined sein, sind aber null
"if (args1[0] == UNASSIGNED) {...} else argCheck(loc, 3, args1.length);" & Co brauchts nur bei named letrec? den "..." teil brauchts ohne named immer, if clause brauchts nur bei named

   JMurmel> (letrec ((a (lambda () b)) (c (a)) (b 2)) (write c))
   
   Error: eval: 'b' is not bound
   error occurred in line 1:1..1:52: (letrec ((a (lambda nil b)) (c (a)) (b 2)) (write c))
   
   JMurmel> :r
   io.github.jmurmel.LambdaJ$MurmelJavaProgram$$Lambda$111/209833425@544a2ea6
   ==> t



((lambda (exp) (apply exp "hallo")) write)
-> parameter exp ist ein builtin. das geht im interpreter und bei speed=0 im compiler, geht nicht bei speed=1 im compiler,
   weil exp wird opencoded und will 2 argumente
-> ggf. warning oder error wenn builtins als parametername verwendet werden
aber:
ggf sollten nur t und nil reserved sein, der rest der bisherigen reserved words sollten nur bei zuweisung verweigert werden (setq, define, defun, letXX dynamic),
-> lambdalist, letXX, labels könnte zulässig werden
-> SBCL: (let ((t 1)) (write t)) gibt fehler, (let ((let 1)) (write let)) geht
   -> (defun let...) geht aber nicht -> Special form is an illegal function name: LET.


Common Lisp Interface Manager
CLIM II Specification
siehe http://bauhh.dyndns.org:8000/clim-spec/index.html und https://github.com/McCLIM/McCLIM



compiler: define/defun in toplevel let/let*/letrec inkl. dynamic zulassen?
-> kein named letXX
-> wäre für let over lambda, und let over lambda simuliert ein singleton, d.h. mehrere funktionen mit gemeinsamem state
-> auch in toplevel "labels"?
-> let over lambda wird wsl dann interessant, wenn man das mit makros generiert, sonst kann man auch globales define+defun machen

geht aber auch so:
JMurmel> (progn (define init) (define inc) (define dec) (let (n) (setq init (lambda (init) (setq n init)) inc (lambda () (setq n (1+ n))) dec (lambda () (setq n (1- n))))))

==> (lambda nil (setq n (1- n)))
JMurmel> (init 5) (writeln (inc)) (writeln (inc)) (writeln (dec))




siehe zeile 5099: bei funktionen ist cddr(enventry) die liste von parametern, compiletime argcount check wär einfach
runtime check brauchts wohl trotzdem für apply und higher order functions

teilweise gibts ringlistenerkennung (cdr(a) == start), das funktioniert aber nur bei listen, wo anfang mit ende verknüpft ist,
nicht aber bei einem loop mittendrin




vector ist ein 1-dimensionales array, strings sind 1-dimensionale array von character, hash-tables sind "assoziative arrays"
welche gemeinsamen eigenschaften haben list, vector/array, string, hash-table?
-> elementzugriff
   (aref    array         0)     -> element mit index 0
   (svref   simple-vector 0)     -> element mit index 0
   (sbit    simple-bit-vector 0) -> bit mit index 0
   (char    string        0)     -> character mit index 0
   (schar   simple-string 0)     -> character mit index 0

   (elt     sequence      0)     -> element mit index 0, (elt nil 0) gibt fehler, (nth 0 nil) geht - gibt nil

   (gethash 0 hash-table)        -> element mit key 0
   (nth     0 list)              -> element mit "index" 0

-> iteration
   mapcar&co, dolist geht nur für lists
   map, reduce geht für list, vector/array, string



vielleicht beginnen mit #() und #H() lesen und schreiben, plus svref und gethash?
-> emitQuoted sollte das auch als konstanten rausschreiben (ggf. endlich alle konstanten immutable machen? und keinen listbuilder sondern ein arrayslice?)
-> und dann schrittweise den rest dazu


vielleicht doch schon mal vector und svref implementieren? vector liefert eindimensionale arrays, 0-basiert, typ T. make-array könnte später kommen, das kann viel mehr
SBCL> (atom #(1 2 3)) ; -> t
svref ist auch ein setf accessor
-> und char/ schar wären accessoren für strings...
   -> char kamma machen, setf/ schar geht nicht weil strings sind immutable
      -> vielleicht von String auf StringBuilder umstellen?
         -> oder auf ropes?
vielleicht auch list->svector und svector->list

svref, (aref), arrayp, vectorp, simple-vector-p

strings sind ein array, vector, aber kein simple-vector
-> wenns nur svref gibt aber kein aref, gibts kein "(setf (aref" problem mit strings. (s)char kamma machen, in murmel macht nth aber dasselbe, schreiben würde laufzeitfehler geben, weil strings sind immutable
-> wsl kann man ewig bei svref bleiben, dann hat murmel nur simple vector == eindimensionale arrays mit anfang=0, so wie Java
-> intern sollte es wsl arrays und arraylist geben, adjustable wär also sinnvoll, element-type irgendwann auch


-> und make-hash-table, hash-table-p, hash-table-count, clrhash, gethash, remhash, maphash, (puthash, , #H(...)), mlib: (setf (gethash...
   erweiterungen nach alexandria: (hash-table-plist hash) -> plist, (plist-hash-table plist) -> hash
   oder                           (hash-table->plist hash) -> plist, (plist->hash-table plist) -> hash
http://clhs.lisp.se/Body/f_mk_has.htm
    make-hash-table &key test size rehash-size rehash-threshold => hash-table
Creates and returns a new hash table.
sbcl hat u.a. ein zusätzliches keyword arg :weakness, damit kann man weakhashmaps erzeugen

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_hash-table-p.html
    hash-table-p object => generalized-boolean
Returns true if object is of type hash-table; otherwise, returns false.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_hash-table-count.html
    hash-table-count hash-table => count
Returns the number of entries in the hash-table. If hash-table has just been created or newly cleared (see clrhash) the entry count is 0.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_clrhash.html
    clrhash hash-table => hash-table
Removes all entries from hash-table, and then returns that empty hash table.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_gethash.html
    gethash key hash-table &optional default => value, present-p
Value is the object in hash-table whose key is the same as key under the hash-table's equivalence test. If there is no such entry, value is the default.
Present-p is true if an entry is found; otherwise, it is false.
setf may be used with gethash to modify the value associated with a given key, or to add a new entry.
When a gethash form is used as a setf place, any default which is supplied is evaluated according to normal left-to-right evaluation rules, but its value is ignored.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_remhash.html
    remhash key hash-table => generalized-boolean
Removes the entry for key in hash-table, if any. Returns true if there was such an entry, or false otherwise.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_maphash.html
    maphash function hash-table => nil
Iterates over all entries in the hash-table. For each entry, the function is called with two arguments--the key and the value of that entry.
The consequences are unspecified if any attempt is made to add or remove an entry from the hash-table while a maphash is in progress,
with two exceptions: the function can use can use setf of gethash to change the value part of the entry currently being processed, or it can use remhash to remove that entry.

mögliche erweiterungen
puthash gibts nicht offiziell, wird man aber wohl für (setf (gethash... brauchen.
SBCL:
* (macroexpand-1 '(setf (gethash 'key h) 'value))
(LET* ((#:HASHTABLE H) (#:NEW1 'VALUE))
  (SB-KERNEL:%PUTHASH 'KEY #:HASHTABLE #:NEW1))

eine funktion, die hashtables aus werten erzeugt, so wie list lists erzeugt, oder vector, gibts offiziell nicht. denkbar wäre
    (hash-table key1 value1 key2 value2...) => hash-hable
und/ oder
    (hash-table plist)
und/ oder
    (hash-table alist)
alexandria https://alexandria.common-lisp.dev/draft/alexandria.html#Hash-Tables hat einige zusätze für hashtables, u.a.
  Function: hash-table-plist table
    Returns a property list containing the keys and values of hash table table.
  Function: plist-hash-table plist &rest hash-table-initargs
    Returns a hash table containing the keys and values of the property list plist. Hash table is initialized using the hash-table-initargs.


spezielle read/write funktionalität scheint in CL nicht vorgesehen, in allen beispielen steht z.B.
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32304110>
    in CL würde man ggf. readtime evaluation verwenden, siehe https://stackoverflow.com/questions/10706024/common-lisp-shorthand-to-initialize-a-hash-table-with-many-entries
denkbar wäre #H(key1 value1 key2 value2...), könnte der murmel reader mittels plist-hash-table umsetzen, und der printer mittels alexandria:hash-table-plist
Serapeum hat dict und erweitert den printer:
    CL-USER> (toggle-pretty-print-hash-table)
    T
    CL-USER> (dict :a 1 :b 2 :c 3)
    (dict
      :A 1
      :B 2
      :C 3
     )
    which is a representation that can be read back in.
Das wiedereinlesen ist aber wsl. nicht dasselbe wie ein readermacro, der reader list halt einen aufruf von dict, der dann irgendwann wirklich passiert



so kann man structs faken:
ein Object[] array wird mit konstanten (also name->0-basiertes integer) indiziert

(defstruct structname membername...) spuckt einige konstanten aus (define structname.member1 0) (define structname.member2 1) usw. und funktionen und/ oder macros zum erzeugen und zugreifen

(defstruct mystruct m1 m2 m3) ->

; constructor
(defun make-mystruct ()
  (make-array (3)))

; getter für m1
(defun mystruct-m1 (ms)
  (svref ms 0))

; getter für m2
(defun mystruct-m2 (ms)
  (svref ms 1))

; getter für m3
(defun mystruct-m3 (ms)
  (svref ms 2))

; setter für m3
(defun |(setf-mystruct-m3)| (ms val)
  (setf (svref ms 2) val))


CL scheints ähnlich zu machen: http://www.lispworks.com/documentation/lw70/CLHS/Body/m_defstr.htm
in CL kann man optional mit (:type ...) die zugrunde liegende struktur angeben, list oder vector oder sonstwas.
und mit (:include ...) kann man veranlassen, dass der neue struct einen bestehenden erweitert
mit (:initial-offset) kann man einen zugrundliegenden vector/ list mit mehreren hinter- oder übereinander liegenden structs überlagern
-> nein, nur ein struct, weil es gibt keinen "placement constructor"
   -> doch, es gehen doch mehrere: die generierten funktionen der verschiedenen structs bekommen einfach eine liste/ einen vector als parameter
CL definiert noch ein typprädikat mystruct-p (ausser man verwendet :type ohne zusätzliches :named), und copy-mystruct

wenn man :type und :named verwendet, dann wird im ersten element der list/ vector 'mystruct abgespeichert, und das kann von mystruct-p verwendet werden




(compile) könnte in etwa so gehen:

kompilierter code muss lernen, freie variablen auch im environment des interpreters zu lesen und mit setq schreiben ((re-)define müsste so eigentlich auch gehen!),
   und interpretierte funktionen aufrufen (diese interpretierten funktionen müssen aber das environment des kompilierten codes sehen, und die Murmel funktion eval
   sollte ein gscheites environment mitbekommen, damit (eval '(lambda...)) aus dem compiler heraus funktionierende closures erstellen kann 
statt toplevelFormToJava() gibts eine andere funktion, es wird nicht das bisherige MurmelProgram geschrieben,sondern anders:
-> für jede freie variable gibts ein lambda, das sucht beim ersten zugriff mit assoc im environment des interpreters, und ersetzt sich selbst durch ein lambda,
   das bei künftigen zugriffen den wert aus dem environment eintrag ausliest
   -> zum zeitpunkt des ersten zugriffs können diese freien variablen existieren oder auch nicht (nur? globale variablen/ funktionen können später dazukommen)
   -> ob diese lambdas in die generierte klasse als member emitted werden müssen oder obs anonyme lambdas sein können?
      -> zum umpatchen brauchts einen namen. könnte aber statt lambda auch instanzen einer klasse sein, die hält das symbol und erst UNDEFINED und später den wert,
         und macht assoc on demand
-> diese klasse braucht also eine referenz auf das environment des interpreters zum zeitpunkt des aufrufes, und auch eine referenz auf den interpreter selbst
-> diese klasse sollte wsl. von MurmelJavaRuntime erben, da muss man halt den interpreter reinpoken statt neu erzeugen

freie variablen suchen/ schreiben und interpreter aufrufen wär bereits jetzt ohne (compile) nützlich, für eval.
-> mit eval kann man das ganze auch testen: eval erzeugt ein interpretiertes lambda, das dann vom kompilierten code aus aufgerufen wird

später könnte damit dann ein repl mit performance (durch compile) entstehen
-> compile in kompiliertem code aufrufen scheint auch nicht schwer, damit könnte man dynamisch neue kompilierte funktionen erzeugen
   -> compile sollte wsl auch makros können?
-> dann würde wsl. auch volles macroexpand-1 im compilierten code gehen oder machbar sein. interpreter müsste iwie das aktuelle environment des compilierten codes bekommen
   -> brauchts dazu eine primitive "environment"? first-class environment wär eh nicht schlecht

umsetzung: evtl wird aus MurmelJavaCompiler eine basisklasse, und abgeleitet MurmelJavaCompiler mit murmeltojavasource/class usw wie bisher, und abgeleitet
compilecompiler mit compile(LambdaJ intp, symbol oder ConsCell code, ConsCell environment)





kompilierte programme: MurmelProgram.body() kann man nur 1x laufen lassen, ab dem zweiten aufruf kommt "duplicate define"
-> alle globals am anfang von body() auf UNASSIGNED setzen, ggf. mittels generierter init-methode
-> in lambdajbm erstmal labels statt defun


tailcallSibling0(Object fn, Object[] oldargs)
tailcallSibling1(Object fn, Object[] oldargs, Object arg)
tailcallSibling2(Object fn, Object[] oldargs, Object arg1, Object arg2)
-> arg array könnte wiederverwendet werden, würde insb. bei let loop viele allokationen einsparen
-> ähnlicher trick wäre im interpreter denkbar, derzeit wächst environment bei tailcalls (aber nur bei dynamic lambdas!)


compiler: (einige) forms die nicht in der tailposition sind (isLast == false) kann man eigentlich mit { forms... } schreiben, ergebnis wird ja nicht benötigt?!?
-> geht nicht innerhalb ?:, weil das braucht eine expression
-> emitForm müsste wohl einen parameter "expr" bekommen und geeignet durchreichen
   -> und bei expr == false müsste (if...) als Java if statt ?: emitted werden, und (cond...) als elsif kette statt ?: kette
   -> eigentlich sollte isLast genügen: isLast == true -> expression ist erforderlich, isLast == false -> keine expression
      -> braucht aber auch noch einen umbau von emitForms, weil das schreibt immer ignored = ...

compiler: wenn rsfx==0 ist, ist die form toplevel oder toplevel in einem defun, und die form wird in "ignoredN = <form>;" reingeschrieben
-> if, let&Co könnten da anders, einfacher rausgeschrieben werden


sollte (format) auf MessageFormat basieren? {1} statt %d usw. oder iwie als alternative?
-> jedenfalls delegiert String.format eh nur zu Formatter, kamma auch gleich direkt verwenden

errorMalformed könnte als ersten parameter ein enum Error übernehmen. das enum hat name und URL, es gibt enumwerte für alle special forms inkl "named let" usw. und "compilation unit".
damit könnte errroMalformed zusatzinfo wie "see http://.../murmel-langref.md#let" ausgeben.


im reader gibts every und some
-> woanders hin schieben?
-> every <-> and, some <-> or. kann man das woanders nutzen? in mlib?

(with-reader-printer (string string) forms...)
-> LambdaJ.pushReaderPrinter(Object, Object)/ popReaderPrinter() umsetzen
   String öffnet eine Datei, nil ändert nix, t setzt stdin/out
-> man sollte wohl angeben können, ob appended wird
   (with-reader-printer (string string) forms...) ; für rewrite (default)
   (with-reader-printer ((string t) (string nil)) forms...) ; optionaler parameter appendp: t ist append, nil (default) ist rewrite
interpreted eval: OpenCodedPrimitive sollte keine implementierung der methode apply brauchen, vgl apply

APPLY Forms as Places http://clhs.lisp.se/Body/05_abe.htm


"(declaim (optimize (safety...": CompilerPrimitives könnten einen ersten parameter safety bekommen, der wird abgefüllt wenn die calls generiert werden
Primitives könnten den aktuellen Wert auswerten
-> achtung: safety=0 sollten nicht die checks während dem kompilieren abdrehen

tests auf testng dataprovider umstellen
die test lispfiles auch kompiliert testen, v.a. wegen der fehlerfiles
einen unittest schreiben dass MurmelJavaProgram.getValue() alle predefined globals enthaelt
-> junit tests mit ...Test.java, testng mit Test... .java

statt überall "throw new LambdaJError(..."
-> funktionen errorArgcount(), errorMalformed(), errorInternal(), usw. einführen, erstmal werfen die eine exception
-> ggf. später statt exception optional einen handler aufrufen -> condition system
  -> solange exceptions geworfen werden, können die funktionen vom interpreter, compiler, compiler rt und generiertem code benutzt werden
     wenn handler gerufen werden, schauts anders aus 

let* dynamic ändert globals für alle threads, sollte threadlocal verwenden

vielleicht sollten CompilerPrimitive und MurmelFunction das gleiche basisinterface haben mit "int type()", CompilerPrimitive und MurmelFunction haben jeweils eine defaultimplementierung
dann brauchts in funcall(Object) kein instanceof mehr?!?
-> instanceof oder zumindest cast (inkl. checkcast) brauchts schon, weil es gibt noch Primitive und ConsCell
-> müssten wohl alle 4 das gleiche basisinterface Funcallable haben, und in funcall(Object, Object...) gibts einen cast, der bei not-a-function fehlschlägt
   -> blöd, das ist wieder ein cast. bleibt wohl nur, funcall zu vermeiden
-> obs den unterschied MurmelFunction vs. CompilerPrimitive überhaupt braucht?
   -> (interpreter-) Primitive ist anders, das hat parameter "ConsCell"



Platform matrix und publishing
https://github.com/actions/setup-java/blob/main/docs/advanced-usage.md#Testing-against-different-platforms

oracle-actions/setup-java` GitHub action
https://www.reddit.com/r/java/comments/tdy6lt/introducing_the_oracleactionssetupjava_github/

Dependency (security) checks mit maven:
https://github.com/jeremylong/DependencyCheck#maven-plugin


https://stackoverflow.com/questions/24487805/lambda-expression-vs-method-reference

compiler: tests für verschachtelte let dynamic
ggf. bei let dynamic als endcall zumindest warnen dass TCO nicht gemacht wird
ggf. für let dynamic statt try/finally eine restore liste basteln, und die wird irgendwie von tailcall abgearbeitet



(declaim (inline... implementieren
-> cdddr könnte inlined werden, dann würden die cdr aufrufe opencoded, und effektiv der ganze cdddr aufruf opencoded

vielleicht tagbody/go/return from/return? könnte für schnellere loops verwendet werden:
  new MurmelFunction(Object... args) {
    Object ret = null;
    label:
    do {
      try {
        forms... // return-from auf gleicher ebene macht "ret=...; break label;", verschachteltes return-from macht "throw new ReturnException(...);"
      }
      catch (GoException e)     { if (e.getLabel() == label) continue label; else throw e; }
      catch (ReturnException e) { if (e.getLabel() == label) return e.getRet(); else throw e; }
    } while (false);
    return ret;
  }.apply(NOARGS);
-> problem wird wieder sein, wenn das go/ return-from eine expression sein muss, wenns in einem if steht das als ?: geschrieben wird.
   -> java funktionen go() und returnFrom() schreiben, die haben formal einen returnvalue, machen aber nur throw



 
gesondertes flag für setq, rplaca, rplacd? --no-mut
gesondertes flag für defmacro?
backquotes, append, assoc, assq



(f 1 2 . l) könnte als flacher call verarbeitet werden: ". l" wird durch den inhalt von l ersetzt
-> kann man das kompilieren? wie?
-> müsste wohl nach (apply f (append '(1 2) l)) entzuckert werden
-> kompilieren ginge, aber eine macro expansion phase wäre wohl unmöglich,
   weil man erst nach der macroexpansion phase weiss, was die macroparameter sind.
   (apply macro...) geht aus demselben grund nicht
   -> man müsste dotted list für alle special forms inkl. makros verweigern,
      dotted list ist für application in den meisten lisps verboten, d.h. dotted list
      nur für function application zulassen wäre eine erweiterung, keine änderung
      (Murmel schluckt/ erlaubt aber stillschweigend dotted lists, behandelt sie wie proper lists)

wär hübsch für rekursiven aufruf einer varargs funktion:
(defun f (a b . c)
  (f a b . c)
-> eigentlich nicht nur für rekursive aufrufe sondern für alle aufrufe, wo eine vararg funktion ihre argumente wohinschicken will

-> im interpreter bräuchte man das wsl. nur in evlis einbauen?
-> und im compiler in funcall/tailcall zur laufzeit appenden? und in opencode!
   -> vielleicht doch besser desugar?
-> aufpassen, dass nicht (f a b) 1x argumente evaluiert und (f a . b) 2x

vielleicht müsste es auch sein:
 (f a b . l) <=> (apply f (append (list a b) l)). oder einfacher: (apply f (list* a b l))
 (f . l)     <=> (apply f l)


müssen die compiler rt funktionen public sein oder reicht protected? geht static?
-> static würd gehen, protected nicht wg. Java compiler fehler
-> import io.github.jmurmel.LambdaJ;
   in getValue(): case "sleep": return (CompilerPrimitive)this::sleep;
                  -> case "sleep": return (CompilerPrimitive)MurmelJavaProgram::sleep;
   in extenvprim(): rt() -> LambdaJ.MurmelJavaProgram

die wellknown symbols (special forms wie let & co, und opencoded functions)
werden static final und in eine static final liste gesteckt,
eine neue symboltable fängt nicht bei nil an sondern bei eben dieser static final liste (nur die interned strings)
damit kann der interpreter (und evalOpencode) auf switch umgestellt werden.
weiterer vorteil: mehrere LambdaJ instanzen sharen die wellknown symbols
-> funkt aber nur mit LambdaJ symboltable, wenn man eine eigene nimmt, weiss die nix von diesen symbols

feature headless und ggf gui
-> nein, features sollten nicht erst zur laufzeit ermittelt werden?
   -> besser: funktion headlessp
MAVEN_OPTS=-Djava.awt.headless=true und dann turtle-funktionen in murmel-langref wieder aufdrehen?

Graalvm download: https://github.com/graalvm/graalvm-ce-builds/releases
native executable bauen: https://github.com/clj-easy/graalvm-clojure/blob/master/doc/clojure-graalvm-native-binary.md

Adopt OpenJDK 8u (alt): https://adoptopenjdk.net/upstream.html?variant=openjdk8&jvmVariant=hotspot
Adoptium OpenJDK 8u (Nachfolger): https://adoptium.net/?variant=openjdk8&jvmVariant=hotspot

SRFI 197 hat chain operator & Co, siehe https://srfi.schemers.org/srfi-197/srfi-197.html
ähnlich wie ->


https://www.reddit.com/r/scheme/comments/somz8y/tail_calls_for_native_targets/
https://github.com/edn-format/edn ist so ne art erweiterte S-expressions spec

mit Class.forName() könnte man eine Klasse mit Custom Primitives laden.
-> der bestehende customenvironment trick geht eh nur im interpreter?!? wär dann nicht mehr nötig
Class.forName() könnte auch absplitten des Compilers in eine andere Klasse ermöglichen, dann würde das verbleibende LambdaJ immer noch als single source file funktionieren

(asynclet threadpool-symbol ((sym form)...) forms)
-> die binding-forms würden asynchron in threads laufen, sym wäre ein promise, innerhalb forms würde sym ggf. blockieren
-> threadpool kann normale threads oder loom threads liefern, nil wäre irgendein defaultpool

Lisp Quine: https://de.wikipedia.org/wiki/Quine_(Computerprogramm)
JMurmel> ((lambda (x)
  (list x (list (quote quote) x)))
 (quote
    (lambda (x)
      (list x (list (quote quote) x)))))

==> ((lambda (x) (list x (list (quote quote) x))) (quote (lambda (x) (list x (list (quote quote) x)))))

oder (stimmt nicht ganz): (define s "(define s %c%s%c) (format t s #\" s #\")") (format t s #\" s #\")
ergebnis:                 (define s "(define s %c%s%c) (format t s #" s #")") (format t s #" s #")

oder: (define s "(define s %c%s%c) (format t s (code-char 34) s (code-char 34))") (format t s (code-char 34) s (code-char 34))





mit -Djava.awt.headless=true gibt (make-frame) eine HeadlessException
-> ggf. eine funktion um einen frame in eine datei zu schreiben? und headlessp
   und bei headless erstellt make-frame nur linecomponent, d.h. alles geht auch headless bis auf open-frame

trace sollte das symbol tracen. in der map steht aber die adresse der funktion, die ändert sich bei load oder re-defun,
und es wird nicht mehr getraced
-> umbauen dass nicht mehr eine hashmap verwendet wird, sondern der environmententry durch eine gewrappte version ersetzt wird?
   -> das würd auch im compiler gehen
   -> wär auch für profiling denkbar

compiler: alle defuns/ defines, nicht nur toplevel
-> zähler mitlaufen lassen
   im pass1 alle gen-methoden mit zähler als suffix generieren
   im pass2 zähler erneut hochzählen und die entsprechende zuweisung generieren
   -> achtung bei macros
-> das brauchts z.b. wenn makros define enthalten
-> und/ oder makros pro toplevel form expandieren, toplevel progn auch

(re-) define im compiler
-> oder doch nicht? braucht man hauptsächlich im REPL



assert, error: https://google.github.io/styleguide/lispguide.xml?showone=Assertions_and_Conditions#Assertions_and_Conditions
function error: http://clhs.lisp.se/Body/f_error.htm
macro assert: http://clhs.lisp.se/Body/m_assert.htm

warum ist assoc in jmurmel drin?
-> assoc, rassoc in mlib jeweils mit optionalem predicate (rassoc ist reverse lookup, sucht statt im car im cdr)
-> assoc-if, rassoc-if
-> support für plists (ähnlich alists aber alist hat tupel, plist hat abwechselnd key und value in einer flachen liste plus eq statt eql),
   symbol-plist wäre optional auch möglich (und get, getf, ...). get verarbeitet symbol plist, getf verarbeitet alleinstehende plists
https://gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html

sollte defmacro eine neue definition pushen und (defmacro n) die vorige wieder herstellen?

alte define syntax zusätzlich unterstützen:
(define ((a 1) (b 2))) ???

interlisp hat
(DEFINEQ
  (DESTRUCTIVE
    (LAMBDA  (n  m)

https://stackoverflow.com/questions/7872852/map-filter-foldr-in-drracket-scheme
https://stackoverflow.com/questions/36960124/foldr-and-foldl-in-drracket
https://srfi.schemers.org/srfi-1/srfi-1.html, https://srfi.schemers.org/srfi-1/srfi-1-reference.scm


Scheme Benchmarks:
https://ecraven.github.io/r7rs-benchmarks/


communicating sequential processes (CSP) ist im prinzip die channels von go, siehe https://en.wikipedia.org/wiki/JCSP
siehe auch https://github.com/hawkir/calispel

https://github.com/stassats/swank-gauche ist ein swank server für gauche,
kamma vielleicht einen swank server für jmurmel abkupfern?!?
siehe auch https://github.com/astine/swank-client/blob/master/swank-description.markdown

#. form
-> form wird zur read zeit ausgewertet

https://github.com/sbcl/sbcl/blob/master/.github/workflows/windows.yml
-> sbcl baut bei jedem push einen windows installer, der liegt dann als artefact beim workflow run, z.b. auf 
   https://github.com/sbcl/sbcl/actions/runs/1034569455

mapXX vielleicht so umbauen, dass auch dotted lists erlaubt sind?
-> oder zusätzlich mapXX*?
sollte apply eine dotted list akzeptieren?
-> oder apply*?
&+ liefert bei integer args die summe als integer mit 2s complement wraparound, auch &- &*
-> oder +&, -&, *&, ggf auch /& für div
    -> Swift hat anscheinend &+, &*, &<<, etc.



java interop:
-> siehe auch LispWorks Java FFI http://www.lispworks.com/documentation/lw70/LW/html/lw-109.htm
-> siehe https://clojure.atlassian.net/browse/CLJ-2365 und https://clojure.atlassian.net/browse/CLJ-2637
Primitive und CompilerPrimitive könnten passende Java interfaces implementieren,
  z.b. Callable, Runnable, Supplier, Consumer, Predicate, defuns und lambdas ebenso
-> vielleicht sollte Primitive, CompilerPrimitive, MurmelFunction einfach diese interfaces erweitern, und die jeweiligen Methoden sind default methoden die auf murmelcode delegieren
   Predicate.test(T) implementieren als apply(Object[0]) != null usw., wenn arity nicht stimmt (also der murmelcode will args) dann gibts eh automatisch einen rt error

parenscript (das ist eine empedded sprache CL -> Javascript) hat die funktion oder makro "chain"
(chain console (log my-list)))) -> console.log(myList)
-> eine ähnliche funktion/ special form könnte Java direkt in den generierten Code injecten

"inline java" könnte man (im compiler) in etwa so machen (interpreter könnte auch on-the-fly zeugs kompilieren)
(java (a b c) "return a + b + c;")
-> (MurmelFunction)(args) -> { /*argCheck(args.length, 3);*/ Object a = args[0]; Object b = args[1]; Object c = args[2]; return a + b + c; }
-> ggf sollten auch (optional?) typen angegeben werden, dann wird eine typumwandlung reingezwickt so wie jmethod
-> vielleicht auch (java args "return args[0]") -> (MurmelFunction)(args) -> { return args[0]; }

CL+J ist ein CFFI Binding CL nach Java: https://common-lisp.net/project/cl-plus-j/
CL+J is a JNI based interface to a Java Virtual Machine through CFFI. It targets safe, exact and complete access to Java 
from Common Lisp with as high integration as possible of the Java and CL respective runtime environments 
(especially at the condition/exception level).
CL+J uses a set of reader dispatch-macros to simplify the Java code interface. In CL+J the traditional "Hello World!" becomes:
  (#_System.out.println (jstr "Hello World!"))

j.u.l logging iwie anbinden?



https://www.reddit.com/r/ProgrammingLanguages/comments/nsktgu/i_built_a_lisp/h0uadn4/
For your error handling, implement two things:

    1 Some sort of non-local jump mechanism that allows you to "return" from arbitrary points on the stack.
    2 Have the interpreter call a designated function whenever an error occurs. As far as your interpreter is concerned,
      "error handling" just means calling the error handling function, without unwinding the stack or doing anything special.
      By #1, the error handler can "return" from the original expression that triggered the error.

With those building blocks, you can implement the equivalent of Common Lisp's condition and restart system entirely in Lisp.
If you make it possible to inspect the stack from Lisp, you also gain the ability to write a debugger in Lisp.
https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html



--add-feature
-> z.B. jm --add-feature test
   -> damit kann man tests per feature expressions ein/ ausschalten

im repl: rplaca, rplacd, setq veraendert die history (die aus conses besteht)
-> :r fuehrt was anderes aus als der interpreter davor

as... konsequenter einsetzen statt numberArgs wenns nur um ein arg geht

macros haben mlib nicht zur verfügung oder doch?
-> checken, ggf. entweder ändern oder dokumentieren
   -> im interpreter sehen die macros defuns, im compiler nicht, weil der compiler das interpreter-eval aufruft

ein eigener macro namespace ist schlecht: zum ueberschreiben muss man wissen, obs ein macro oder eine funktion ist
-> gibts ein macro "m" dann hat "(defun m..." keine auswirkung
-> vielleicht so lassen und defun für ein macro verbieten, so wie defun für special forms verboten ist?

funktion error (und/ oder exit) wirft eine exception die am programmende den errorlevel bestimmt
         fatal wirft eine exception die am programmende den errorlevel bestimmt plus fehlermeldung mit murmelstack
mlib-test vervollständigen

sollte mlib equal einen fallback nach Objects.equals() haben?



einige samples:
JMurmel> (->> (mapcar print 'abcde) reverse list->string)
#\a
#\b
#\c
#\d
#\e
==> "edcba"

JMurmel> (->> '(0 1 2) print (mapcar 1+) print (mapcar (lambda (n)(expt n 2))) print (reduce +) round)
(0 1 2)
(1 2 3)
(1.0 4.0 9.0)
==> 14

JMurmel> (mapcar (lambda (n) (prog1 (-> n princ (->> 1+ 1+) princ (expt 2) round princ) (terpri))) '(0 1 2 3 4 5))
024
139
2416
3525
4636
5749
==> (4 9 16 25 36 49)



http://www.ulisp.com/show?37VY hat ein einfaches objekt system
vgl. Graham, Paul "On Lisp"  Prentice-Hall, New Jersey, 1994, pp. 348-379, available online at http://www.paulgraham.com/onlisptext.html.
siehe auch http://forum.ulisp.com/t/a-simple-object-system-for-ulisp/622

; makes jmurmel crash with java.lang.StackOverflowError
(defun f names
  (if names
        (cons (car names) (f (cdr names))) ; this line should be "(cons (car names) (apply f (cdr names)))"
    nil))
-> stackoverflow ist wsl ok, sollte aber in eine Murmelfehlermeldung umgelenkt werden



https://www.reddit.com/r/lisp/comments/lxlyvb/why_does_cl_have_such_a_strange_way_of_obtaining/gpo0swr/
it is undefined behavior according to the ANSI spec to redefine a standard function
-> car cdr cons koennten im interpreter open coded sein zwecks performance

symbolhandling ist fishy
-> symbole sollten nicht per stringvergleich sondern ueber identity verglichen werden
  -> dadurch wirkt sich der unterschied interned/ nicht interned nicht wie gewuenscht aus, und gensym funktioniert nicht richtig
-> der reader sollte symbole auf UC stellen (ausser ||), symboltable sollte case sensitive sein
(erl) -> compiler sollte nicht stringvergleich machen

gensym im compiler (momentan gehts nur in macros)


Macros im compiler
-> http://clhs.lisp.se/Body/m_defmac.htm:
-> If a defmacro form appears as a top level form... Users must ensure that the body of the macro can be evaluated at compile time if it is referenced within the file being compiled.



...jdk-15\bin\jlink --output jm --compress=2 --no-header-files --no-man-pages --strip-debug --add-modules java.base,jdk.compiler,jdk.zipfs
-> das baut anscheinend ein ca. 30MB grosses JRE mit den Java Modulen, dies fuer JMurmel braucht
-> jdk.localedata noch dazu?

obiges hab ich experimentell ermittelt, jdeps sollte exakte aussagen treffen;
...\lambda>jdeps --print-module-deps target\jmurmel.jar
java.base,java.compiler,java.desktop,java.management
-> jlink --output jm --compress=2 --no-header-files --no-man-pages --strip-debug --add-modules java.base,java.compiler,java.desktop,java.management
-> da ist aber kein compiler dabei

Java 18:
jlink --output jm --compress=2 --no-header-files --no-man-pages --strip-debug --add-modules java.base
-> interpreter-only minimalversion, kein awt, swing, jfr, compiler, locale, 26MB

jlink --output jm --compress=2 --no-header-files --no-man-pages --strip-debug --add-modules java.base,jdk.compiler,jdk.zipfs
-> ohne awt, swing, jfr, 38MB

jlink --output jm --compress=2 --no-header-files --no-man-pages --strip-debug --add-modules java.base,java.desktop,jdk.compiler,jdk.zipfs,jdk.jfr
-> mit awt + swing + jfr, 52MB
-> ohne locale, (format-locale t "de-DE" "%g" pi) printet 3.12..., locale wird ignoriert

jlink --output jm --compress=2 --no-header-files --no-man-pages --strip-debug --add-modules java.base,java.desktop,jdk.compiler,jdk.zipfs,jdk.jfr,jdk.localedata
-> w.o. + locale, 61MB



cmdlineflags wos let aber nicht letXXX oder ggf named let gibt
-> --no-scheme, auch null? und ggf if abdrehen
-> dann gibts nur mehr not bound, kein undefined value


vielleicht --jar und --fatjar: --fatjar erzeugt ein jar, das auch die rt enthaelt

packages koennte man mit namenspraefixes umsetzen, und bei einer symboltabelle/ einem environment bleiben.
laesst sich dann auch sehr einfach auf Java packages/ klassennamen umlegen

compiletojar, tojava, ... sollten eigentlich in der Sprache angeboten werden
-> erst mit packages, weil dann brauchts weniger parameter

--srcjar option: die sourcen dazuzippen? oder extra srcjar?

ConsCell: methoden rplaca und rplacd, jeweils fuer die subklassen geeignet umsetzen: rplacd bei zwei IntArraySlices koennte die arrays in ein groesseres hintereinanderkopieren
-> erstmal nicht in der sprache anbieten, spart aber einige casts v.a. in den tests
-> und nth und nthcdr, anschliessend caaar, cdddr, ... mit nth bzw. nthcdr implementieren
-> achtung: es koennten mehrere ArraySlices auf das selbe array zeigen.
   -> Vor naiv implementiertem rplacd: alle ArraySlices zeigen auf die gleichen daten,
      aenderung ueber ein slice ist in den anderen sichtbar
   -> nachdem ein ArraySlice das array durch ein anderes ersetzt hat: slices zeigen auf verschiedene daten,
      anderungen ueber ein slice sind NICHT mehr in anderen sichtbar-> FEHLER
   -> rplacd ist nur fuer ListConsCell umsetzbar, nicht fuer ArraySlice, rplaca wuerd wsl gehen

Den Compiler retargetable machen: methoden die Code ausspucken nach emit... umbenamsen und in eine klasse zusammenfassen, es koennte mehrere solche klassen
fuer mehrere zielsprachen geben, formsTo... bekommen so eine instanz als parameter
oder visitor pattern?


ConsCell.iterator() ueberladen: iterator(typ) liefert verschiedene iteratoren:
circular list liefert nach der ersten runde hasNext() == false
                                            fehler
dotted list liefert beim zugriff auf letztes element letztes element das element
                                                                     hasNext() == false, hasNext(true) liefert das letzte element
                                                                     fehler
sowohl mapcar wie auch maplist zulassen: der iterator liefert entweder nth(cursor++) oder nthcdr(cursor++)


trace und features refactoren:
nicht int features sondern Set<Features>
statt trace >= TRC_XXX.ordinal -> methode TraceLevel.ge(TraceLevel)

anzahl parameter duerfen begrenzt werden, auch bei varargs
-> hilft bei cdr(arg) im compiler, umsetzen, dokumentieren, global mit dem wert erfinden, vgl. http://...

funktion compile, und dem interpreter beibringen, wie kompilierte funktionen aufgerufen werden, und/ oder Primitive auf MurmelFunction umstellen
-> erst CPS im compiler umsetzen

IntArraySlice, CharArraySlice, ...
string->array koennte so ein CharArraySlice liefern, readbytes koennte ein ByteArraySlice liefern
nth und nthcdr in ConsCell rein, fuer alle subklassen geeignet umsetzen
cdddr sollte als nthcdr(3) umgesetzt werden, caaar als nth(3), caddr als car(nth(2)) usw., dann waeren die ArraySlices effizienter
readObj koennte ArraySlice liefern, wenn eine sexpression mehr als X member hat, vielleicht als pratt parser umsetzen?
-> dann gibts aber keinen platz fuer zeilennummern, also ggf einen gesonderten reader zum lesen von stdin basteln



https://github.com/phoe/cafe-latte
CL conditions
dynamic variables
tagbody go
block/return-from
restart
-> block/return-from koennte wsl mit "label: for (;;) break label;" umgesetzt werden (plus das richtige result setzen)
-> tagbody/go koennte wsl mit "label: for (;;) continue label;" umgesetzt werden
-> beides wird in Java lambdas nicht gehen, ggf. im lambda "throw ..."


zeilentabellen lisp->java mitfuehren und ins java verpacken? dann koennte ein catch im main() den stacktrace umschluesseln
-> javacode sollte mehr linefeeds bekommen
-> javaassist kann linenumbertable fuer methoden neu setzen, die enthalten sourcefile und sourcezeile
-> apache bcel wsl auch, bcel ist in java mitgepackt: com.sun.org.apache.bcel

wenns namespaces gibt, sollte :: wahrscheinlich i-wie mit import verheiratet werden

vielleicht doch nil=null und t=Boolean.TRUE? Interpreter ggf. angleichen

refactor: alles was zum interpreter gehoert in eine neue Klasse LambdaJ.MurmelInterpreter heben
-> auf gleichem Level wie LambdaJ.MurmelJavaCompiler und LambdaJ.MurmelJavaProgram
-> dann koennten Interpreter und Program das gleiche Interface fuer getValue(), getFunction() haben
-> runtime aussen vor lassen? oder es gibt methoden die implementieren z.B. write, und getrennte wrapper fuer interpreter und kompilierte programme

im environment des compilers koennt man den typ der symbole mitfuehren, das wuerde compiletime typchecks ermoeglichen.

das main von compilierten programmen sollte am ende ggf alles abbauen. vielleicht eine methode dazu, die auch exposed ist? interpreter auch?
oder macht das der gc, wenns keine referenz auf das kompilierte programm/ den interpreter mehr gibt?

compiler:
-> irgendwie alles (lambdas, letXXX, labels, ...) in eine funktion (Object[] args, var Function next) -> Object verpacken
-> next kann ggf. von der funktion woanders hin gebogen werden (fuer continuations)
-> ohne continuations: lambda ggf. vorerst nicht aendern sondern per apply(Function, params, next) ausfuehren lassen
-> mit continuations: eine continuation ist statt normalem lambda: (Function continuation, Object[] args, var Function next) -> Object
    -> die continuation kann "continuation" in next reinstecken, dann wird "continuation" als naechstes ausgefuehrt statt "next"
-> body hat dann einen loop, der die funktionen der reihe nach aufruft, jeweils das gelieferte "next" ist die naechste funktion
-> statt var parameter koennen funktionen auch ein tupel (Object, Function) als result liefern

-> kann man eigentlich im interpreter gleich machen

Tracer bei JSR-223 nutzen.

irgendwie mit maven von Murmel nach Java uebersetzen, dann kann man einen teil einer app in murmel schreiben und fast nahtlos von Java aufrufen
-> https://stackoverflow.com/questions/2147115/generating-sources-by-running-a-projects-java-class-in-maven

in C gibts #pragma line, das schreibt debug infos ins Object file. gibts in Java annotations und einen processor, der dasselbe macht?
-> debuggen von kompilierten murmel programmen

anstatt letXX, cond im compiler auszuprogrammieren, kann man auch desugar programmieren, idealerweise als macroexpander
-> desugar ist macroexpand mit zus. macros fuer let-> lambda usw.
-> stattdessen kann man ggf. cons, car, cdr, +, - usw inlinen (aber erst schauen ob das was bringt)

die generierten programme koennten ein cmd arg "--repl" unterstuetzen: mit dem arg gibts nach body() kein exit() sondern repl()

filevariablen statt der gefaehrlichen cmdline args

JSR223 vielleicht in ein zweites jar verpacken?





tests von lis.py verpacken

eval, interpretExpressions & Co aendern:
- einige init methoden die setzen in, out, environment, symboltable
- eine methode eval(ConsCell progam), das ist ein wrapper um das bisherige eval, der wrapper schmeisst eine exception falls nicht
  initialisiert.
- die sprache ist ja eine liste von ConsCells, mit so einem API waers ggf. einfacher/ natuerlicher einen anderen Parser davor
  zu schalten
- das derzeitige eval kann nur eine expression, listen arbeiten repl() bzw. interpretExpressions() ab. Obiger eval wrapper
  sollte auch listen koenen



current-cc ist eigentlich immer cdr(form)
-> bzw. cons(cdr(form), current_cc) oder append?!?
        -> und wie baut man das environment wieder ab?
            -> statt cons-> cons3(cons3(cdr(form), current_cc, newScope), env)?
        -> und wie uebersetzt man das nach java?
   damit koennt ma continuations umsetzen, und eval waer ueberhaupt nicht mehr rekursiv, statt return-> form=current_cc; continue;
   -> das waer dann "compile with continuations", continuations kann man muss aber nicht in der sprache anbinden



vielleicht eval irgendwie umbauen, dass ein symbol nicht den wert sondern den enventry liefert? das waer dann ein lvalue,
und wuerde ein allfaelliges setf ermoeglichen. (get-record recordsymbol propertysymbol) wuerde dann auch ein (symbol . value)
tupel liefern, und dann wuerd (setf (get-record my-record propertysymbol) value) gehen
eigentlich muesste das nur in eval->symbol und zip eingebaut werden



Objektorientierung: records (default immutable) und "methoden" ala go (wenn eine funktion als ersten parameter einen recordtyp uebernimmt)
(defrecord mutable? symbol (extends...) symbol...) -> symbol ; eigener namespace fuer records? feldsymbols haben automatisch eigenen namespace, weil sie in einer hashtable des records drinstehen ?
(make-record mutable? recordsymbol (propertysymbol value)...) -> record
(get-record recordform propertysymbol) -> value
-> unions auch reinzwicken? z.B.
   (defrecord mutable? symbol (extends...) propertysymbol-oder-unionsymbol+(propertysymbol...)...)
   -> ohne typen fuer die properties wird das wohl zu kompiziert, und java hat auch keine unions
      ohne typen sind unions auch nicht notwendig, weil man kann einem symbol verschiedene records zuweisen

methoden, also funktionen die nur fuer einen bestimmten recordtyp zutreffen, kann man machen, muss man aber nicht

vielleicht die recordnamen in den selben namespace geben wie double, integer, string (die noch keinen haben)?




tabs im scanner richtig zaehlen
col += tabsize
col = (col / tabsize) * tabsize



koennt ma namespaces irgendwie so einfuehren:
namespace xxx biegt topenv woandershin
define schreibt nicht in topenv sondern ins package
export schreibt ins topenv
import kopiert (symbol . value) entries aus einem anderen env ins aktuelle
assoc sucht erst im aktuellen namespace, dann in topenv (wie spielt das mit den gestapelten environments zusammen?)
-> namespaces nach C oder object files waeren irgendwie C und H files bzw getrennte object files - export schreibt ins .h file
   bzw exportiert das symbol aus dem object file





neuen parser: (evtl while, for (list) umsetzen?)
program ::= stmt*

stmt ::= exp ';'

exp ::= assignment | lambda | case | block | application

assignment ::= s '=' exp
-> (define s exp)

case ::= 'case' (exp block)* 'esac'
-> (cond (exp block))

block ::= '{' stmt* '}'
-> (progn explist)

lambda ::= function(p1, p2) block   		; implicit symbol 'self' for recursion
-> (lambda (p1 p2) stmt*)

application ::= builtin | f(exp1*)			; add, sub, ..., pair, list 
-> (f explist)

(e1, e2)
-> '(e1 e2)

atomexp ::= atom
-> atom


builtin:
pair(exp1, exp2)
-> (exp1 . exp2)

list(exp1, exp2, exp3)			; list(exp*)
-> (list exp1 exp2 exp3)

add(1, 2)
-> (+ 1 2)



ConsCell methoden double carAsDouble(), long carAsLong() einfuehren
-> und DoubleConsCell, LongConsCell, das hat zusaetzlich Java primitive datentypen als car und ueberlaedt die methoden



printSEx: if (car(list) == sQuote) print "'" + printSex(cdr(list))
der reader sollte wsl ' immer auf (quote... umsetzen, egal ob quote unterstuetzt wird oder nicht

umbenennen:
lispStdout -> lispPrinter
ObjectReader -> LispReader, #readObj -> #read
ObjectWriter -> LispPrinter, #printObj -> #print





solange es kein rplaca gibt, koennte man int, float, double und ggf kurze/ lange strings/ symbols in jeweils massgeschneiderte ConsCell stecken
-> muesste sehr hohe speichereinsparung und performanceverbesserung bringen
sollte es rplaca geben, muesste dieses logik haben, um bei typaenderung in ein neues ConsCell umzukopieren und dieses ggf. einzuhaengen
-> oder typaenderungen sind verboten
-> oder man kann optional einen typ angeben, dann ists schnell und der typ ist fix, ohne typangabe ists langsam aber der typ darf sich aendern
z.B. statt
(lambda (a b) (...))
(lambda (integer a double b) (...))
 

nach bytecode compilieren: der bytecode wird dann in einem threaded interpreter abgearbeitet
der interpreter sollte wsl direkt in eval drinstehen wg. TCO. der threaded interpreter kann
direkt cons, car, cdr, +-*/ usw. ist sonst aber sehr aehnlich dem interpreter-eval.
die threaded interpreter "methode" bekommt environment
und ein int (oder char? eher byte[]) array mit bytecode und arbeitet den bytecode ab:
char[] code; XXX env;
int ip = 0;
top:
while (ip < code.length) {
switch (code[ip++]) {
case car: extendenv(...; continue top;
case cons: extendenv(new ConsCell(...; continue top;
}





Speicherverwaltung selber machen in Java oder C:

Der Heap ist ein Array int[], 2 aufeinander folgende elemente sind ein cons
allokation ist bump allocation. ist der zaehler == array.length muss das array in ein neues groesseres array umkopiert werden
die ints werden als bitmasks interpretiert:
  die niedgristen 3 bits sind der variablen typ (d.h. 8 typen moeglich)
  intwert >> 3 ist der wert:
    pointer: ein index ins array
    symbol: ein index in die (getrennte) symboltabelle
    number: die zahl
    usw.

statt 3 bits koennten mehr oder weniger verwendet werden, wird die max anzahl cons zells groesser oder kleiner
in C koennten (muessen aber nicht) Pointer wirkliche Pointer statt indizes sein, wuerde eine indirektion sparen,
  diese muessten beim realloc des arrays (i.e. heap vergroessern) aber angepasst werden
optionales GC waer moeglich, in C und in Java, oder man laessts weg fuer kleine programme
generational heaps waeren auch moeglich, dann muesste es verschiedene pointertypen geben, jeder typ zeigt in einen anderen heap
das ergebnis einer expression koennte aus dem Heap (der auch garbage enthaelt) rausextrahiert werden, indem man wie ein GC dem root folgt,
  das ergebnis ist dann ein array das kleiner ist als der heap, also der GC komprimierte Heap

das waer alles in einer Klasse Heap { cons(); car(); cdr(); } abstrahierbar, nur die klasse kennt ConsCell
-> interface ConsCell waer moeglich. beim ArrayHeap sieht ConsCellImpl so aus:
ConsCellImpl {
    ConsCell(int n);
    Object car() { return get(n); }
    Object cdr() { return get(n+1); }
    Object get(int n) {
        int type = heap[n] & 1<<3;
        int value = heap[n] >> 3;
        switch (type) {
        case integer:
        case pointer: return new Integer(carvalue);
        case symbol: return symtab[carvalue];
        case float: // Float#intBitsToFloat benutzen, vgl NaN trick in Lox
        }
    }
    rplaca(newVal)...
    rplacd(newVal)...
}

ohne variablenzuweisungen braucht man eigentlich keinen gc und kein refcounting, einfach beim return
"alles freigeben, was nicht im returnvalue steckt" ?!?
-> so wirds wohl rust machen, plus borrow checker
-> "alles freigeben, was nicht im returnvalue steckt" ist aber nicht so leicht



einen debugger in eval einbauen? expression fuer expression? und/ oder eine special form break? :break symbol?

flag ob die identifier auf UC umgestellt werden sollen
flag fuer symbols:
--symbols=uc ... symbole werden beim lesen auf UC umgestellt
--symbols=ci ... symbole werden nicht umgestellt, aber case insensitive verglichen
--symbols=cs ... symbole werden as is verwendet, case sensitive verglichen





Generic S-Expression reader/ writer: (<n>:<octets>)





cadr, caddr, cadar, cddr, ... in eval verwenden und schauen, wieviel kleiner eval wird
-> solche primitiven wuerden auch Lisp programme schneller machen weil weniger assoc aufrufe
-> ein optimizer, der in define oder lambda reingezwickt wird, koennte (car (cdr o)) erkennen und durch (cadr o) ersetzen
   mit rekursivem abstieg muesste man nur current node und naechste stufe betrachten
   car/car  -> caar
   car/caar -> caaar
   car/cadr -> caadr
   car/cdr  -> cadr
   car/cdar -> cadar
   car/cddr -> caddr

   cdr/car  -> cdar
   cdr/caar -> cdaar
   cdr/cadr -> cdadr
   cdr/cdr  -> cddr
   cdr/cdar -> cddar
   cdr/cddr -> cdddr


LambdaJError extends RuntimeException   ... abstract
Syntaxerror extends LambdaJError        ... nur eval
RuntimeError extends LambdaJError       ... nur primitives

k.a. wieviel die ConsCell casts bremsen
Alternatives Objectmodell mit weniger casts:

interface Value {
    default car() { throw new Error("not a cons"); }
    default cdr() { throw new Error("not a cons"); }
    String toString();
}

interface Atom extends Value {
    Object value;
    String toString() { return value.toString(); }
}

class ConsCell extends Value {
    Value car, cdr;
}

Value car(Value v) { return v.car(); }
Value cdr(Value v) { return v.cdr(); }
ConsCell cons(Value car, Value cdr) { return new ConsCell(car, cdr); }


Doku: ein Custom Parser koennte statt parsen eine Liste liefern (koennte z.B. hardcodiert
mit new ConsCell zusammengestoppelt werden) und intern() koennte mittels String.intern() umgesetzt werden.
Anmerkung: Symbols sind Strings, Stringliterale in der o.a. Liste sind bereits mit String.intern() bearbeitet,
  dazu passt die Umsetzung der Parsermethode intern() mittels String.intern()
Anmerkung 2: Lisp Strings werden als LambdaJString repraesentiert
Anmerkung 3: intern() mit einer HashMap waer auch nicht schwer


Doku: https://en.wikipedia.org/wiki/Peano_axioms enthaelt natuerliche Zahlen basierend auf Mengen,
koennte eine Anleitung sein, wie man Zahlen in einem Lisp ohne Zahlen umsetzen kann
0 = nil
1 = succ(0) = '(0) = '(nil)
2 = succ(1) = '(0 1) = '(nil (nil))
3 = succ(2) = '(0 1 2) = '(nil (nil (nil)))

addition:
(add (a b) (if (null? b) a (add '(nil a) (cdr b))) ; oder so aehnlich

multiplikation:
(mul (a b) (if (null? b) nil (add a (mul a (cdr b)))) ; oder so aehnlich


Clisp:
(setf zero ())                                ; -> zero = NIL

;(define (cons a b) (lambda (f) (f a b)))      ; define?
;(define (car c) (c (lambda (a b) a)))         ; define?
;(define (cdr c) (c (lambda (a b) b)))         ; define?

(defun succ (a) (cons zero a))                ; das geht

(setf one (succ zero))                        ; -> one = (NIL)
(setf two (succ (succ zero)))                 ; -> two = (NIL NIL)
(setf three (succ (succ (succ zero))))        ; -> three = (NIL NIL NIL)
(setf four (succ (succ (succ (succ zero)))))  ; -> four = (NIL NIL NIL NIL)

(defun add (a b) (if (eq b zero)
                     a
                     (add (succ a) (cdr b))))

(defun mul (a b) (if (eq b zero)
                     zero
                     (add a (mul a (cdr b)))))

;(write (add two three)) ; -> (NIL NIL NIL NIL NIL) aka six
;(write (mul four three)) ; -> (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) aka twelve
(write (mul zero three)) ; -> NIL aka zero

(defun true (a b) a)
(defun false (a b) b)
(defun my-if (a b c) (funcall a b c))

;(write (my-if #'false one two)) ; -> (NIL NIL) aka two


;(define and (lambda (p q) (if p q false)))    ; define?
;(define or  (lambda (p q) (if p true  q)))    ; define?



Multithreading waer eigentlich nicht so schwer: solange nix geschrieben werden kann, braucht eigentlich nur die
Symboltable synchronized sein ?!?
-> und das environment?

Methoden ConsCell toList(), toArray(), toMap(), iterator(), stream()??? map() flatMap()
-> damit bekommt man Ergebnis-Daten raus am Ende des Lisp Programms
-> Wenn man dem Interpreter eine read Funktion ins Environment mitgibt, bekommt man auch Daten rein (abgesehen vom
Lesen von stdin). So eine read Funktion koennte z.B auch XML oder JSON nach ConsCells parsen
    -> iterator ist erledigt
(write (((lambda () (lambda () (quote (1 2 3))))))) ; geht nur in scheme siehe apply.lisp



Tail recursion erkennen: es wird eine Funktion aufgerufen, die im environment 1 hoeher ist (?)
oder wenigstens loop einbauen
-> einfache ists alle tailcalls zu optimieren

eval hat einige endrekursive aufrufe. koennte man eliminieren.
vielleicht noch einen zweiten levelzaehler einfuehren, dann kann man den level fuer eval und (kleinere) rekursionstiefe anzeigen

eigentlich passiert die rekursion ja in eval:
evlis, evcon & co inline expandieren, und das letzte listenelement nicht mit rekursion aufrufen sondern
manuell tail recursion elimination machen.

PROBLEM: function calls haben ein geändertes environment extenv
-> einen stack aus extenvs aufbauen: ein int "stackarray" in dem merkt man sich, wieviele elemente vorne
drangepickt wurden und nach verarbeiten des calls entfernt werden müssen 

dann werden nicht nur tail rekursionen wegoptimiert, sondern alle tail calls. es ruft zwar die eine Lisp funktion
eine andere auf, aber in wirklichkeit laeuft nur der code der einzigen Java-methode eval. 





printObj auf loop umbauen, zirklen erkennen, vgl collection.toString()

LambdaJError extends RuntimeException
Syntaxerror extends LambdaJError
RuntimeError extends LambdaJError
ExtFuncError extends RuntimeError



readObj umbauen dass (a . b) eingelesen werden kann?

flag ob die identifier auf UC umgestellt werden sollen

lisp write liefert als ergebnis den parameter
-> LambdaJ liefert (quote t)

eine map builtinfunc->name damit printObj die funktionsnamen ausgeben kann?
zweite map fuer FFI funktionen s.u.?

eval ins environment einhaengen?

Datentypen Strings, double, int unterstuetzen

Klasse Atom extends String, Function extends String. car ist dann entweder UnaryOperator oder Atom oder Function.
Das wär für Integer und Double erweiterbar.

FFI: eine special form "extlabels". funktioniert aehnlich wie labels,
aber statt funktionsdefinitionen gibt man einen Klassennamen an (und vielleicht ein zusaetzliches optionales namenspraefix,
damit man im falle von gleichnamige methoden in zwei klassen "namespaces" zum trennen verwenden kann), und
von dieser klasse werden alle public methoden mit der Signatur UnaryOperator<Pair> ins Environment gesteckt.
Oder statt reflection: "extlabels" bekommt den Namen einer statischen methode die liefert eine Map Funktionsname->UnaryOperator<Pair>

try/ catch für javacode in eval statt in d, weil da kann man in der Fehlermeldung die Expression ausgeben

JDBC vielleicht objectorientiert anbinden?
funktion nativequery bekommt eine datasource, einen SQL string und eine Liste mit (parameternameatom . wertexpression) tupeln

nativeinsert könnte für batchinserts eine Liste von listen mit (parameternameatom . wertexpression) tupeln bekommen und eine liste 
mit ints liefern (ein int für jede insert-tupel-liste)

lexikalische closures



Erledigt:

welches ergebnis liefert lambda mit einer liste als body?
-> sollte ergebnis der letzten form sein

Klasse Builtin statt UnaryOperator<Pair> einführen

eq vergleicht identität, was macht Lisp? https://stackoverflow.com/questions/547436/whats-the-difference-between-eq-eql-equal-and-equalp-in-common-lisp
-> checken ob das passt, z.b. (eq (cons (quote 1) (quote 2)) (cons (quote 1) (quote 2))) ist nicht identisch aber gleich (?)
-> GNU CLISP v2.49+ liefert NIL

Eine JUnit funktion, die liest alle lisp files aus einem verzeichnis und führt sie aus.
erwartetes Ergebnis bzw. fehlermeldung steht in der datei in einem kommentar drin, z.B.
; result:(1 . 2)
oder
; error-prefix: SyntaxError in line 12:
und ggf.
; output: Hallo Welt

Lambda -> LambdaJ

Vielleicht in printObj umlenken:
(quote t) -> "t"
null -> "nil"

beim scannen zeile und spalte mitzählen und in fehlermeldung einbauen

apply fuer lambdas, siehe apply.lisp

verschiedene konstruktoren fuer Pair und ueberladene cons brauchts wahrscheinlich nicht, cons(Object,Object) muesste reichen

builtin write-line
-> common lisp hat das, parameter muss aber ein string sein

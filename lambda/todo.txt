test fuer eval nil und eval t, ggf. symbol t einfuehren

tests und fehlertests fuer number und operatoren

error tests fuer lambda/ builtin mit zuviel/ zuwenig parametern aufrufen

Benchmark



eval ins environment einhaengen?

Variable INTERNAL-TIME-UNITS-PER-SECOND
Builtins GET-INTERNAL-REAL-TIME, GET-INTERNAL-RUN-TIME, SLEEP

Numbersupport mit flags ausschalten?
Optional BigDecimal statt Double?

Vielleicht doch set/setq, define/defun vgl ABOUT LISP https://graham.main.nc.us/~bhammel/graham/lisp.html
Vielleicht mit flags ein/ausschalten?

isNaN, isInfinite, isFinite
-> ggf. parameter "Error bei NaN, Infinity etc."
div, remain, trunc, round, abs
weitere operatoren aus java.lang.Math (oder StrictMath?)



Vielleicht car, cdr, cons, Pair in eine Basisklasse LambdaJRuntime rausziehen?
LambdaJ koennte man als Lisp Programm sehen, das von Hand nach Java uebersetzt wurde,
und ein Lisp Programm verwendet Lisp Runtime wie car, cdr, ... .
Falls ein LambaJ Compiler kommt, wuerden erzeugte Java Programme dieselbe Runtime verwenden.
Fuer interpretierte Programme gibts die Builtin-Wrapper, die Parameter-Checks machen und
die Argument-Liste in Argumente wandeln.

Falls Compiler, sollte der nicht nur ein Programm sondern z.B. *.lisp uebersetzen,
ggf. mit timestampcheck

eval, evlis, evcon vielleicht in haendischem CPS?!?



printObj auf loop umbauen, zirklen erkennen, vgl collection.toString()



Tail recursion erkennen: es wird eine Funktion aufgerufen, die im environment 1 hoeher ist (?)
oder wenigstens loop einbauen
-> einfacher ists alle tailcalls zu optimieren

eval hat einige endrekursive aufrufe. koennte man eliminieren.
vielleicht noch einen zweiten levelzaehler einfuehren, dann kann man den level fuer eval und (kleinere) rekursionstiefe anzeigen

eigentlich passiert die rekursion ja in eval:
evlis, evcon & co inline expandieren, und das letzte listenelement nicht mit rekursion aufrufen sondern
manuell tail recursion elimination machen.

PROBLEM: function calls haben ein geaendertes environment extenv
-> einen stack aus extenvs aufbauen: ein int "stackarray" in dem merkt man sich, wieviele elemente vorne
drangepickt wurden und nach verarbeiten des calls entfernt werden müssen 

dann werden nicht nur tail rekursionen wegoptimiert, sondern alle tail calls. es ruft zwar die eine Lisp funktion
eine andere auf, aber in wirklichkeit laeuft nur der code der einzigen Java-methode eval. 



(loop for thing in list
   do (if (numberp thing)
          (format nil “I’m a number: ~a~%” thing)
          (format nil “Not a number!~%”)

(defun factorial(x)
  (reduce '* (loop for a from x downto 1 collect a)))



Datentyp Strings, char unterstuetzen



(write (((lambda () (lambda () (quote (1 2 3))))))) ; geht nur in scheme siehe apply.lisp





LambdaJError extends RuntimeException
Syntaxerror extends LambdaJError
RuntimeError extends LambdaJError
ExtFuncError extends RuntimeError



readObj umbauen dass (a . b) eingelesen werden kann?

flag ob die identifier auf UC umgestellt werden sollen

lisp write liefert als ergebnis den parameter
-> LambdaJ liefert (quote t)

eine map builtinfunc->name damit printObj die funktionsnamen ausgeben kann?
zweite map fuer FFI funktionen s.u.?



FFI: eine special form "extlabels". funktioniert aehnlich wie labels,
aber statt funktionsdefinitionen gibt man einen Klassennamen an (und vielleicht ein zusaetzliches optionales namenspraefix,
damit man im falle von gleichnamige methoden in zwei klassen "namespaces" zum trennen verwenden kann), und
von dieser klasse werden alle public methoden mit der Signatur UnaryOperator<Pair> ins Environment gesteckt.
Oder statt reflection: "extlabels" bekommt den Namen einer statischen methode die liefert eine Map Funktionsname->UnaryOperator<Pair>

try/ catch für javacode in eval statt in d, weil da kann man in der Fehlermeldung die Expression ausgeben

JDBC vielleicht objectorientiert anbinden?
funktion nativequery bekommt eine datasource, einen SQL string und eine Liste mit (parameternameatom . wertexpression) tupeln

nativeinsert koennte fuer batchinserts eine Liste von listen mit (parameternameatom . wertexpression) tupeln bekommen und eine liste 
mit ints liefern (ein int für jede insert-tupel-liste)

lexikalische closures



Erledigt:

welches ergebnis liefert lambda mit einer liste als body?
-> sollte ergebnis der letzten form sein

Klasse Builtin statt UnaryOperator<Pair> einfuehren

eq vergleicht identitaet, was macht Lisp? https://stackoverflow.com/questions/547436/whats-the-difference-between-eq-eql-equal-and-equalp-in-common-lisp
-> checken ob das passt, z.b. (eq (cons (quote 1) (quote 2)) (cons (quote 1) (quote 2))) ist nicht identisch aber gleich (?)
-> GNU CLISP v2.49+ liefert NIL

Eine JUnit funktion, die liest alle lisp files aus einem verzeichnis und führt sie aus.
erwartetes Ergebnis bzw. fehlermeldung steht in der datei in einem kommentar drin, z.B.
; result:(1 . 2)
oder
; error-prefix: SyntaxError in line 12:
und ggf.
; output: Hallo Welt

Lambda -> LambdaJ

Vielleicht in printObj umlenken:
(quote t) -> "t"
null -> "nil"

beim scannen zeile und spalte mitzaehlen und in fehlermeldung einbauen

apply fuer lambdas, siehe apply.lisp

verschiedene konstruktoren fuer Pair und ueberladene cons brauchts wahrscheinlich nicht, cons(Object,Object) muesste reichen

builtin write-line
-> common lisp hat das, parameter muss aber ein string sein

Datentyp double, (nicht int) unterstuetzen

eq fuer number korrigieren
-> oder eq lassen und = einfuehren, achtung beim vergleichen von double!
-> vielleicht = mit optionalem drittem double parameter fuzz fuer die genauigkeit

+ - * / %, factorial beispiel

car, cdr umstellen dass sie Object uebernehmen
-> dann gibts einen cast in car/cdr statt 1000 casts ueberall

vielleicht "Object car(Object)" und "Pair pcar(Object)"?
-> Eruebrigt sich ggf. durch Umstellen von car(Pair) nach car(Object) 

die parameterchecks ignorieren zuviele argumente

numberp, ggf. atom korrigieren
symbol? vs atom vs numberp

<, >, usw checken ob Double#compareTo Vorteile bzgl. NaN und +- 0.0 hat, derzeit passiert Unboxing

tests fuer atom, consp, listp, symbolp, numberp

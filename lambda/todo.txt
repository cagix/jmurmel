http://www.gigamonkeys.com/book/macros-defining-your-own.html
(defmacro when (condition . body) (list 'if condition (cons 'progn body)))

JMurmel> (macroexpand-1 '(when (= 1 2) (write "hello ") (write "world")))
==> (if (= 1 2) (progn (write "hello ") (write "world")))


Macros im compiler
-> http://clhs.lisp.se/Body/m_defmac.htm:
-> If a defmacro form appears as a top level form... Users must ensure that the body of the macro can be evaluated at compile time if it is referenced within the file being compiled.

init(), parser vs. in aufraeumen

die ByteArrayReader aus den tests wegputzen




...jdk-15\bin\jlink --output jm --compress=2 --no-header-files --no-man-pages --strip-debug --add-modules java.base,jdk.compiler,jdk.zipfs
-> das baut anscheinend ein ca. 30MB grosses JRE mit den Java Modulen, dies fuer JMurmel braucht
-> jdk.localedata noch dazu?



cmdlineflags wos let aber nicht letXXX oder ggf named let gibt
-> --no-scheme, auch null? und ggf if abdrehen
-> dann gibts nur mehr not bound, kein undefined value


vielleicht --jar und --fatjar: --fatjar erzeugt ein jar, das auch die rt enthaelt

packages koennte man mit namenspraefixes umsetzen, und bei einer symboltabelle/ einem environment bleiben.
laesst sich dann auch sehr einfach auf Java packages/ klassennamen umlegen

compiletojar, tojava, ... sollten eigentlich in der Sprache angeboten werden
-> erst mit packages, weil dann brauchts weniger parameter

--srcjar option: die sourcen dazuzippen? oder extra srcjar?

ConsCell: methoden rplaca und rplacd, jeweils fuer die subklassen geeignet umsetzen: rplacd bei zwei IntArraySlices koennte die arrays in ein groesseres hintereinanderkopieren
-> erstmal nicht in der sprache anbieten, spart aber einige casts v.a. in den tests
-> und nth und nthcdr, anschliessend caaar, cdddr, ... mit nth bzw. nthcdr implementieren
-> achtung: es koennten mehrere ArraySlices auf das selbe array zeigen.
   -> Vor naiv implementiertem rplacd: alle ArraySlices zeigen auf die gleichen daten,
      aenderung ueber ein slice ist in den anderen sichtbar
   -> nachdem ein ArraySlice das array durch ein anderes ersetzt hat: slices zeigen auf verschiedene daten,
      anderungen ueber ein slice sind NICHT mehr in anderen sichtbar-> FEHLER
   -> rplacd ist nur fuer ListConsCell umsetzbar, nicht fuer ArraySlice, rplaca wuerd wsl gehen

Den Compiler retargetable machen: methoden die Code ausspucken nach emit... umbenamsen und in eine klasse zusammenfassen, es koennte mehrere solche klassen
fuer mehrere zielsprachen geben, formsTo... bekommen so eine instanz als parameter
oder visitor pattern?


ConsCell.iterator() ueberladen: iterator(typ) liefert verschiedene iteratoren:
circular list liefert nach der ersten runde hasNext() == false
                                            fehler
dotted list liefert beim zugriff auf letztes element letztes element das element
                                                                     hasNext() == false, hasNext(true) liefert das letzte element
                                                                     fehler
sowohl mapcar wie auch maplist zulassen: der iterator liefert entweder nth(cursor++) oder nthcdr(cursor++)


trace und features refactoren:
nicht int features sondern Set<Features>
statt trace >= TRC_XXX.ordinal -> methode TraceLevel.ge(TraceLevel)

anzahl parameter duerfen begrenzt werden, auch bei varargs
-> hilft bei cdr(arg) im compiler, umsetzen, dokumentieren, global mit dem wert erfinden, vgl. http://...

funktion compile, und dem interpreter beibringen, wie kompilierte funktionen aufgerufen werden, und/ oder Primitive auf MurmelFunction umstellen
-> erst CPS im compiler umsetzen

IntArraySlice, CharArraySlice, ...
string->array koennte so ein CharArraySlice liefern, readbytes koennte ein ByteArraySlice liefern
nth und nthcdr in ConsCell rein, fuer alle subklassen geeignet umsetzen
cdddr sollte als nthcdr(3) umgesetzt werden, caaar als nth(3), caddr als car(nth(2)) usw., dann waeren die ArraySlices effizienter
readObj koennte ArraySlice liefern, wenn eine sexpression mehr als X member hat, vielleicht als pratt parser umsetzen?
-> dann gibts aber keinen platz fuer zeilennummern, also ggf einen gesonderten reader zum lesen von stdin basteln



https://github.com/phoe/cafe-latte
CL conditions
dynamic variables
tagbody go
block/return-from
restart
-> block/return-from koennte wsl mit "label: for (;;) break label;" umgesetzt werden (plus das richtige result setzen)
-> tagbody/go koennte wsl mit "label: for (;;) continue label;" umgesetzt werden
-> beides wird in Java lambdas nicht gehen, ggf. im lambda "throw ..."


zeilentabellen lisp->java mitfuehren und ins java verpacken? dann koennte ein catch im main() den stacktrace umschluesseln
-> javacode sollte mehr linefeeds bekommen
-> javaassist kann linenumbertable fuer methoden neu setzen, die enthalten sourcefile und sourcezeile
-> apache bcel wsl auch, bcel ist in java mitgepackt: com.sun.org.apache.bcel

wenns namespaces gibt, sollte :: wahrscheinlich i-wie mit import verheiratet werden

vielleicht doch nil=null und t=Boolean.TRUE? Interpreter ggf. angleichen

refactor: alles was zum interpreter gehoert in eine neue Klasse LambdaJ.MurmelInterpreter heben
-> auf gleichem Level wie LambdaJ.MurmelJavaCompiler und LambdaJ.MurmelJavaProgram
-> dann koennten Interpreter und Program das gleiche Interface fuer getValue(), getFunction() haben
-> runtime aussen vor lassen? oder es gibt methoden die implementieren z.B. write, und getrennte wrapper fuer interpreter und kompilierte programme

im environment des compilers koennt man den typ der symbole mitfuehren, das wuerde compiletime typchecks ermoeglichen.

das main von compilierten programmen sollte am ende ggf alles abbauen. vielleicht eine methode dazu, die auch exposed ist? interpreter auch?
oder macht das der gc, wenns keine referenz auf das kompilierte programm/ den interpreter mehr gibt?

compiler:
-> irgendwie alles (lambdas, letXXX, labels, ...) in eine funktion (Object[] args, var Function next) -> Object verpacken
-> next kann ggf. von der funktion woanders hin gebogen werden (fuer continuations)
-> ohne continuations: lambda ggf. vorerst nicht aendern sondern per apply(Function, params, next) ausfuehren lassen
-> mit continuations: eine continuation ist statt normalem lambda: (Function continuation, Object[] args, var Function next) -> Object
    -> die continuation kann "continuation" in next reinstecken, dann wird "continuation" als naechstes ausgefuehrt statt "next"
-> body hat dann einen loop, der die funktionen der reihe nach aufruft, jeweils das gelieferte "next" ist die naechste funktion
-> statt var parameter koennen funktionen auch ein tupel (Object, Function) als result liefern

-> kann man eigentlich im interpreter gleich machen

Tracer bei JSR-223 nutzen.

irgendwie mit maven von Murmel nach Java uebersetzen, dann kann man einen teil einer app in murmel schreiben und fast nahtlos von Java aufrufen
-> https://stackoverflow.com/questions/2147115/generating-sources-by-running-a-projects-java-class-in-maven

in C gibts #pragma line, das schreibt debug infos ins Object file. gibts in Java annotations und einen processor, der dasselbe macht?
-> debuggen von kompilierten murmel programmen

anstatt letXX, cond im compiler auszuprogrammieren, kann man auch desugar programmieren, idealerweise als macroexpander
-> desugar ist macroexpand mit zus. macros fuer let-> lambda usw.
-> stattdessen kann man ggf. cons, car, cdr, +, - usw inlinen (aber erst schauen ob das was bringt)

die generierten programme koennten ein cmd arg "--repl" unterstuetzen: mit dem arg gibts nach body() kein exit() sondern repl()

filevariablen statt der gefaehrlichen cmdline args

JSR223 vielleicht in ein zweites jar verpacken?





tests von lis.py verpacken

mit maven replace regex aus murmelref.lisp eine murmelref.md datei erzeugen

eval, interpretExpressions & Co aendern:
- einige init methoden die setzen in, out, environment, symboltable
- eine methode eval(ConsCell progam), das ist ein wrapper um das bisherige eval, der wrapper schmeisst eine exception falls nicht
  initialisiert.
- die sprache ist ja eine liste von ConsCells, mit so einem API waers ggf. einfacher/ natuerlicher einen anderen Parser davor
  zu schalten
- das derzeitige eval kann nur eine expression, listen arbeiten repl() bzw. interpretExpressions() ab. Obiger eval wrapper
  sollte auch listen koenen



current-cc ist eigentlich immer cdr(form)
-> bzw. cons(cdr(form), current_cc) oder append?!?
        -> und wie baut man das environment wieder ab?
            -> statt cons-> cons3(cons3(cdr(form), current_cc, newScope), env)?
        -> und wie uebersetzt man das nach java?
   damit koennt ma continuations umsetzen, und eval waer ueberhaupt nicht mehr rekursiv, statt return-> form=current_cc; continue;
   -> das waer dann "compile with continuations", continuations kann man muss aber nicht in der sprache anbinden



vielleicht eval irgendwie umbauen, dass ein symbol nicht den wert sondern den enventry liefert? das waer dann ein lvalue,
und wuerde ein allfaelliges setf ermoeglichen. (get-record recordsymbol propertysymbol) wuerde dann auch ein (symbol . value)
tupel liefern, und dann wuerd (setf (get-record my-record propertysymbol) value) gehen
eigentlich muesste das nur in eval->symbol und zip eingebaut werden



Objektorientierung: records (default immutable) und "methoden" ala go (wenn eine funktion als ersten parameter einen recordtyp uebernimmt)
(defrecord mutable? symbol (extends...) symbol...) -> symbol ; eigener namespace fuer records? feldsymbols haben automatisch eigenen namespace, weil sie in einer hashtable des records drinstehen ?
(make-record mutable? recordsymbol (propertysymbol value)...) -> record
(get-record recordform propertysymbol) -> value
-> unions auch reinzwicken? z.B.
   (defrecord mutable? symbol (extends...) propertysymbol-oder-unionsymbol+(propertysymbol...)...)
   -> ohne typen fuer die properties wird das wohl zu kompiziert, und java hat auch keine unions
      ohne typen sind unions auch nicht notwendig, weil man kann einem symbol verschiedene records zuweisen

methoden, also funktionen die nur fuer einen bestimmten recordtyp zutreffen, kann man machen, muss man aber nicht

vielleicht die recordnamen in den selben namespace geben wie double, integer, string (die noch keinen haben)?




tabs im scanner richtig zaehlen
col += tabsize
col = (col / tabsize) * tabsize

Fexpr unterstuetzen, in eigenen Namespace stecken und diesen Namespace nur in define auswerten/ fexpr aufrufen/ aufloesen
-> sind das dann effektiv macros?


koennt ma namespaces irgendwie so einfuehren:
namespace xxx biegt topenv woandershin
define schreibt nicht in topenv sondern ins package
export schreibt ins topenv
import kopiert (symbol . value) entries aus einem anderen env ins aktuelle
assoc sucht erst im aktuellen namespace, dann in topenv (wie spielt das mit den gestapelten environments zusammen?)
-> namespaces nach C oder object files waeren irgendwie C und H files bzw getrennte object files - export schreibt ins .h file
   bzw exportiert das symbol aus dem object file





Vielleicht in define den Lisp Code nach Java uebersetzen und mit tools.jar uebersetzen? Und aus dem erzeugten class file
ein neues primitive basteln?
-> denkbar waere ein aeusserer und ein innerer compiler. der aeussere uebersetzt nach java/c/..., der innere nach bytecode
-> vor dem compiler koennten transformationen laufen wie z.b. let->lambda, dann brauchte der compiler und eine allfaellige vm
   nicht so viele features haben
   -> oder der (bytecode) compiler erzeugt code der nur weniger vm features braucht



define sollte das aktuelle environment erweitern, nicht das globale
zusaetzlich define-global einfuehren (ist das dasselbe wie defconst? solange keine re-definition und kein set -> ja)
-> oder auch nicht: Scheme define != Old Lisp define





neuen parser: (evtl while, for (list) umsetzen?)
program ::= stmt*

stmt ::= exp ';'

exp ::= assignment | lambda | case | block | application

assignment ::= s '=' exp
-> (define s exp)

case ::= 'case' (exp block)* 'esac'
-> (cond (exp block))

block ::= '{' stmt* '}'
-> (progn explist)

lambda ::= function(p1, p2) block   		; implicit symbol 'self' for recursion
-> (lambda (p1 p2) stmt*)

application ::= builtin | f(exp1*)			; add, sub, ..., pair, list 
-> (f explist)

(e1, e2)
-> '(e1 e2)

atomexp ::= atom
-> atom


builtin:
pair(exp1, exp2)
-> (exp1 . exp2)

list(exp1, exp2, exp3)			; list(exp*)
-> (list exp1 exp2 exp3)

add(1, 2)
-> (+ 1 2)



ConsCell methoden double carAsDouble(), long carAsLong() einfuehren
-> und DoubleConsCell, LongConsCell, das hat zusaetzlich Java primitive datentypen als car und ueberlaedt die methoden

LambdaJSymbol.equals, equalsIgnoreCase aufraeumen

multivalue let: wenn funktionen mehrere werte zurueckgeben, koennte ein erweitertes letXXX zuweisen:
(let ((r1 r2 (multivaluefunction)))
   (print r1)
   (print r2))
-> gibts schon in scheme




printSEx: if (car(list) == sQuote) print "'" + printSex(cdr(list))
der reader sollte wsl ' immer auf (quote... umsetzen, egal ob quote unterstuetzt wird oder nicht

umbenennen:
lispStdout -> lispPrinter
ObjectReader -> LispReader, #readObj -> #read
ObjectWriter -> LispPrinter, #printObj -> #print


synchronized ueberlegen





Evolution of Lisp, pp 66 ff: Macros nach dem paper von Timothy P. Hart in 1963
pp73ff: modernes defmacro
-> besser wie lispy2


solange es kein rplaca gibt, koennte man int, float, double und ggf kurze/ lange strings/ symbols in jeweils massgeschneiderte ConsCell stecken
-> muesste sehr hohe speichereinsparung und performanceverbesserung bringen
sollte es rplaca geben, muesste dieses logik haben, um bei typaenderung in ein neues ConsCell umzukopieren und dieses ggf. einzuhaengen
-> oder typaenderungen sind verboten
-> oder man kann optional einen typ angeben, dann ists schnell und der typ ist fix, ohne typangabe ists langsam aber der typ darf sich aendern
z.B. statt
(lambda (a b) (...))
(lambda (integer a double b) (...))
 

nach bytecode compilieren: der bytecode wird dann in einem threaded interpreter abgearbeitet
der interpreter sollte wsl direkt in eval drinstehen wg. TCO. der threaded interpreter kann
direkt cons, car, cdr, +-*/ usw. ist sonst aber sehr aehnlich dem interpreter-eval.
die threaded interpreter "methode" bekommt environment
und ein int (oder char? eher byte[]) array mit bytecode und arbeitet den bytecode ab:
char[] code; XXX env;
int ip = 0;
top:
while (ip < code.length) {
switch (code[ip++]) {
case car: extendenv(...; continue top;
case cons: extendenv(new ConsCell(...; continue top;
}

ggf. auch in den interpreter einige funktionen wie +/- "inlinen"





Speicherverwaltung selber machen in Java oder C:

Der Heap ist ein Array int[], 2 aufeinander folgende elemente sind ein cons
allokation ist bump allocation. ist der zaehler == array.length muss das array in ein neues groesseres array umkopiert werden
die ints werden als bitmasks interpretiert:
  die niedgristen 3 bits sind der variablen typ (d.h. 8 typen moeglich)
  intwert >> 3 ist der wert:
    pointer: ein index ins array
    symbol: ein index in die (getrennte) symboltabelle
    number: die zahl
    usw.

statt 3 bits koennten mehr oder weniger verwendet werden, wird die max anzahl cons zells groesser oder kleiner
in C koennten (muessen aber nicht) Pointer wirkliche Pointer statt indizes sein, wuerde eine indirektion sparen,
  diese muessten beim realloc des arrays (i.e. heap vergroessern) aber angepasst werden
optionales GC waer moeglich, in C und in Java, oder man laessts weg fuer kleine programme
generational heaps waeren auch moeglich, dann muesste es verschiedene pointertypen geben, jeder typ zeigt in einen anderen heap
das ergebnis einer expression koennte aus dem Heap (der auch garbage enthaelt) rausextrahiert werden, indem man wie ein GC dem root folgt,
  das ergebnis ist dann ein array das kleiner ist als der heap, also der GC komprimierte Heap

das waer alles in einer Klasse Heap { cons(); car(); cdr(); } abstrahierbar, nur die klasse kennt ConsCell
-> interface ConsCell waer moeglich. beim ArrayHeap sieht ConsCellImpl so aus:
ConsCellImpl {
    ConsCell(int n);
    Object car() { return get(n); }
    Object cdr() { return get(n+1); }
    Object get(int n) {
        int type = heap[n] & 1<<3;
        int value = heap[n] >> 3;
        switch (type) {
        case integer:
        case pointer: return new Integer(carvalue);
        case symbol: return symtab[carvalue];
        case float: // Float#intBitsToFloat benutzen, vgl NaN trick in Lox
        }
    }
    rplaca(newVal)...
    rplacd(newVal)...
}

ohne variablenzuweisungen braucht man eigentlich keinen gc und kein refcounting, einfach beim return
"alles freigeben, was nicht im returnvalue steckt" ?!?
-> so wirds wohl rust machen, plus borrow checker
-> "alles freigeben, was nicht im returnvalue steckt" ist aber nicht so leicht



backticks und , ggf. auch ,@ im scanner einbauen?
(defun constant-adder (a)
  (eval `(lambda (b) (+ (quote ,a) b))))

einen debugger in eval einbauen? expression fuer expression? und/ oder eine special form break? :break symbol?

utils: combine, list, nth, nhtcdr, c*r

Hashmaps
-> make-hash-table
   get-hash key -> value

flag ob die identifier auf UC umgestellt werden sollen
flag fuer symbols:
--symbols=uc ... symbole werden beim lesen auf UC umgestellt
--symbols=ci ... symbole werden nicht umgestellt, aber case insensitive verglichen
--symbols=cs ... symbole werden as is verwendet, case sensitive verglichen

Vielleicht doch set/setf/setq, vgl ABOUT LISP https://graham.main.nc.us/~bhammel/graham/lisp.html
rplaca, rplacd
Vielleicht ein "Imperative Paket" mit flags ein/ausschalten?

        if(car(exp) == s_define)                        // "define"
          return(extend_top(car(cdr(exp)),
                            eval(car(cdr(cdr(exp))), env)));
        if(car(exp) == s_setb) {                        // "set!"
          obj *pair   = assoc(car(cdr(exp)), env);
          obj *newval = eval(car(cdr(cdr(exp))), env);
          setcdr(pair, newval);
          return newval;
        }

am besten setf weglassen, weil das macht serious magic
-> set ... belegt den ersten gefundenen wert im environment neu. dynamic, lexical, global, halt dort, wos assoc zuerst findet
           beide argumente werden evaluiert
-> setq ... wie set aber das erste argument wird nicht evaluiert
-> rplaca, rpclacd http://clhs.lisp.se/Body/f_rplaca.htm
   rplaca cons object => cons
   rplacd cons object => cons





LambdaJString.value von String auf char[] umstellen?
-> wuerde ggf. builtins rund um java.lang.Character erleichtern
-> char ist 16 bit
-> Java11 speichert String.value nicht als char[] sondern byte[], diese Speicherersparnis waer dann verloren



In einer LISP Datei nach dem Ende einer Toplevel form koennten Daten stehen, die wuerden von read gelesen
-> Beispiel machen
LambdaJ> (write (read)) "Hello, World!"
"Hello, World!"
==> t





Generic S-Expression reader/ writer: (<n>:<octets>)

// Files can be loaded into the REPL
scala> :load /sites/repl-test.scala
Loading /sites/repl-test.scala...
res2: Int = 4
res3: Int = 6

-> vielleicht :save und (load <string>)


builtin oder special form fuer try/catch:
try = (lambda (func catch-handler finally) (
  try { return func(); }
  catch (Exception e) { return catch-handler(e); }
  finally { finally(); }
)





cadr, caddr, cadar, cddr, ... in eval verwenden und schauen, wieviel kleiner eval wird
-> solche primitiven wuerden auch Lisp programme schneller machen weil weniger assoc aufrufe
-> ein optimizer, der in define oder lambda reingezwickt wird, koennte (car (cdr o)) erkennen und durch (cadr o) ersetzen
   mit rekursivem abstieg muesste man nur current node und naechste stufe betrachten
   car/car  -> caar
   car/caar -> caaar
   car/cadr -> caadr
   car/cdr  -> cadr
   car/cdar -> cadar
   car/cddr -> caddr

   cdr/car  -> cdar
   cdr/caar -> cdaar
   cdr/cadr -> cdadr
   cdr/cdr  -> cddr
   cdr/cdar -> cddar
   cdr/cddr -> cdddr

beispiel, wie man einen logger einhaengen kann.

LambdaJError extends RuntimeException   ... abstract
Syntaxerror extends LambdaJError        ... nur eval
RuntimeError extends LambdaJError       ... nur primitives

k.a. wieviel die ConsCell casts bremsen
Alternatives Objectmodell mit weniger casts:

interface Value {
    default car() { throw new Error("not a cons"); }
    default cdr() { throw new Error("not a cons"); }
    String toString();
}

interface Atom extends Value {
    Object value;
    String toString() { return value.toString(); }
}

class ConsCell extends Value {
    Value car, cdr;
}

Value car(Value v) { return v.car(); }
Value cdr(Value v) { return v.cdr(); }
ConsCell cons(Value car, Value cdr) { return new ConsCell(car, cdr); }


nice to have: apply mit zuviel/ zuwenig args fuer ein lambda: ueberschuessige args koennten gemeinsam mit dem letzten als liste uebergeben werden,
fehlende als null.


Doku: ein Custom Parser koennte statt parsen eine Liste liefern (koennte z.B. hardcodiert
mit new ConsCell zusammengestoppelt werden) und intern() koennte mittels String.intern() umgesetzt werden.
Anmerkung: Symbols sind Strings, Stringliterale in der o.a. Liste sind bereits mit String.intern() bearbeitet,
  dazu passt die Umsetzung der Parsermethode intern() mittels String.intern()
Anmerkung 2: Lisp Strings werden als LambdaJString repraesentiert
Anmerkung 3: intern() mit einer HashMap waer auch nicht schwer


Doku: https://en.wikipedia.org/wiki/Peano_axioms enthaelt natuerliche Zahlen basierend auf Mengen,
koennte eine Anleitung sein, wie man Zahlen in einem Lisp ohne Zahlen umsetzen kann
0 = nil
1 = succ(0) = '(0) = '(nil)
2 = succ(1) = '(0 1) = '(nil (nil))
3 = succ(2) = '(0 1 2) = '(nil (nil (nil)))

addition:
(add (a b) (if (null? b) a (add '(nil a) (cdr b))) ; oder so aehnlich

multiplikation:
(mul (a b) (if (null? b) nil (add a (mul a (cdr b)))) ; oder so aehnlich


Clisp:
(setf zero ())                                ; -> zero = NIL

;(define (cons a b) (lambda (f) (f a b)))      ; define?
;(define (car c) (c (lambda (a b) a)))         ; define?
;(define (cdr c) (c (lambda (a b) b)))         ; define?

(defun succ (a) (cons zero a))                ; das geht

(setf one (succ zero))                        ; -> one = (NIL)
(setf two (succ (succ zero)))                 ; -> two = (NIL NIL)
(setf three (succ (succ (succ zero))))        ; -> three = (NIL NIL NIL)
(setf four (succ (succ (succ (succ zero)))))  ; -> four = (NIL NIL NIL NIL)

(defun add (a b) (if (eq b zero)
                     a
                     (add (succ a) (cdr b))))

(defun mul (a b) (if (eq b zero)
                     zero
                     (add a (mul a (cdr b)))))

;(write (add two three)) ; -> (NIL NIL NIL NIL NIL) aka six
;(write (mul four three)) ; -> (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) aka twelve
(write (mul zero three)) ; -> NIL aka zero

(defun true (a b) a)
(defun false (a b) b)
(defun my-if (a b c) (funcall a b c))

;(write (my-if #'false one two)) ; -> (NIL NIL) aka two


;(define and (lambda (p q) (if p q false)))    ; define?
;(define or  (lambda (p q) (if p true  q)))    ; define?



Multithreading waer eigentlich nicht so schwer: solange nix geschrieben werden kann, braucht eigentlich nur die
Symboltable synchronized sein ?!?
-> und das environment?
 
Methoden ConsCell toList(), toArray(), toMap(), iterator(), stream()??? map() flatMap()
-> damit bekommt man Ergebnis-Daten raus am Ende des Lisp Programms
-> Wenn man dem Interpreter eine read Funktion ins Environment mitgibt, bekommt man auch Daten rein (abgesehen vom
Lesen von stdin). So eine read Funktion koennte z.B auch XML oder JSON nach ConsCells parsen
    -> iterator ist erledigt



The read syntax for characters objects is simple: #\ followed by the desired character. 



Vielleicht car, cdr, cons, ConsCell in eine Basisklasse LambdaJRuntime rausziehen?
LambdaJ koennte man als Lisp Programm sehen, das von Hand nach Java uebersetzt wurde,
und ein Lisp Programm verwendet Lisp Runtime wie car, cdr, ... .
Falls ein LambaJ Compiler kommt, wuerden erzeugte Java Programme dieselbe Runtime verwenden.
Fuer interpretierte Programme gibts die Builtin-Wrapper, die Parameter-Checks machen und
die Argument-Liste in Argumente wandeln.
-> public static nested class LambdaJRuntime + "import static LambdaJ.*"
   damit gaebs nur wenig Aenderungen in LambdaJ, und externer Code haette auch Zugriff mittels "import static LambdaJ.*" 

Falls Compiler, sollte der nicht nur ein Programm sondern z.B. *.lisp uebersetzen,
ggf. mit timestampcheck



(loop for thing in list
   do (if (numberp thing)
          (format nil “I’m a number: ~a~%” thing)
          (format nil “Not a number!~%”)

(defun factorial(x)
  (reduce '* (loop for a from x downto 1 collect a)))

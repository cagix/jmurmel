(scan alist) liefert automatisch das erwünschte (values '(key . value) more)
scan-plist dazu?
scan-iterator dazu für JFFI?
-> oder "jscan" ? vielleicht auch java.sql.ResultSet?

(limit-if generator pred)
-> liefert einen generator mit (values v (and more (pred v)))
(limit-if generator skip-pred linit-pred)


last-n: last mit optionalem parameter N siehe http://clhs.lisp.se/Issues/iss209_w.htm

funktion (error . args) ähnlich wie scheme: schreibt alle argumente mit (write arg nil) und dann (fatal)
-> eher was für mlib

funktion "describe" wär nicht so schwer

evenp, oddp mit x & 0x1 machen.

https://github.com/cl21/cl21 ist Common Lisp 2021
-> neuerfindungen in Murmel sollten dagegen gecheckt werden, z.B. hash literals (defvar *hash* #H())

Hashmaps
-> make-hash-table
   get-hash key -> value

Lambdaj hat assoceq, Emacs Lisp hat assq, ggf umbenamsen, evtl. als primitive anbieten
assoc, delete, member, rassoc, remove use eql in Common Lisp
In Emacs Lisp they have counterparts that use eq instead: assq, delq, memq, rassq, remq
-> siehe https://yoo2080.wordpress.com/2013/08/16/differences-between-common-lisp-and-emacs-lisp/

IO vielleicht auf NIO2 Channels aufsetzen? https://blogs.oracle.com/javamagazine/post/java-nio-nio2-buffers-channels-async-future-callback
Concurrent access to file I/O is handled by the interface java.nio.channels.SeekableByteChannel.
The main implementation of this interface (FileChannel) can hold the current position of where you are reading from a file,
as well as the position in the file that you are writing to.
This means you can have multiple threads reading from and/or writing to the same channel at different positions, making for faster file I/O.

Helidon ist eine Art Application Server als Jar
https://blogs.oracle.com/javamagazine/post/you-dont-always-need-an-application-server-to-run-jakarta-ee-applications?=2-
HelidonSE hat ein eigenes API basierend auf Lambdas, HelidonMP kopiert man zu einer JEE app dazu

http://t3x.org/s9fes/pretty-print.scm.html ist ein public domain pretty printer

(min numbers...), (max numbers...), (gcd integers...), (lcm integers...)
-> siehe https://www.youtube.com/watch?v=UVUjnzpQKUo

ggf. ein subset von lisp printer umsetzen http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_writecm_p_rintcm_princ.html
prin1 object &optional output-stream => object

prin1 produces output suitable for input to read.
princ is just like prin1 except that the output has no escape characters.
print is just like prin1 except that the printed representation of object is preceded by a newline and followed by a space.
pprint is just like print except that the trailing space is omitted and object is printed with the *print-pretty* flag non-nil to produce pretty output.

lisp eol von cmdline parameter auf lisp global umstellen
-> oder write uebernimmt liste mit keyword/value tupel: (write obj flags...), z.B.
   (write "Hallo" (list ('eol-style 'lisp) ('escape-atoms t) ('max-length 20) ('pprint t)))
-> oder write uebernimmt *optionale* liste, fallback ist eine globale variable *print-environment* mit soner liste
   (write "Hallo") ; write benutzt *print-environment*
   (write "Hallo" (cons ('(max-length 20) *print-environment*))) ; write benutzt argument


funktion fatal dokumentieren, ggf. umbenamsen

https://people.eecs.berkeley.edu/~bh/ssch27/appendix-cl.html
beschreibt unterschiede zw. scheme und CL und ist damit ein guter ueberblick ueber CL, auch file open/ close

ANSI-CL hat die beiden funktionen lisp-implementation-type, lisp-implementation-version
-> https://franz.com/support/documentation/9.0/ansicl/dictentr/lisp-imp.htm

cl hat with-open-file


CDI und EJB aehnlich :: integrieren?
-> dazu brauchts eigentlich einen Lookup im Java-Scope, d.h. BeanProvider.getContextualReference() muss i-wie integriert werden
   -> DeltaSpike so verpacken, dass i-wie ein CustomEnvironmentSupplier uebrigbleibt
   -> kann man das aufrufen eines CustomEnvironmentSupplier in eine Murmel Funktion verpacken?

:: macht im prinzip dasselbe wie CL create-method
-> ggf parameterreihenfolge anpassen
   hinweis in murmel-langref.lisp

zus Primitives: https://learnxinyminutes.com/docs/common-lisp/
(expt x y) -> x hoch y, wurzelziehen? oder ist das (x hoch 1/y)?
(intern string) -> symbol
-> intern ist case preserving (intern "aaa") -> |aaa|, anscheinend macht der reader uppercase, und symbol lookup ist case sensitive
AND, OR, XOR, NOT
-> brauchts eigentlich nicht, ist sugar ueber if
null? brauchts eigentlich nur in scheme, (null? x) -> (not x)
-> umbenamsen


Datei IO
(pprint (read (open typ "/Users/ashokkhanna/lisp/test-pprint.lisp"))) ; typ koennte 'utf-8 oder 'ansi oder auch 'url oder 'ftp sein
-> datentyp File
-> funktion (open string...) -> File ; koennte eine menge pathelemente bekommen, setzt die mittels pathsep zusammen vgl NIO
            (close file) -> t
            (read-line file) -> String oder nil
            (read-all-lines file) -> (line...)
bringt aber nur was, wenns auch stringmanipulationsfunktionen gibt
-> string->charlist
-> (split splitchars sting) -> (elements...)

(char-int C:character): integer expr ; Converts character to integer.
(int-char I:integer): character expr ; Converts integer to character.


(load 'utf-8 "lispfile.lisp")
-> erster optionale parameter ist ein symbol fuer den Zeichensatz

Stringfunktionen: format kann auch strings zusammensetzen
strings sind eine LISP sequence, fuer sequence gibts
-> subseq sequence start &optional end => subsequence

(concatenate 'string "all" " " "together" " " "now") =>  "all together now"
(concatenate 'list "ABC" '(d e f) #(1 2 3) #*1011)
=>  (#\A #\B #\C D E F 1 2 3 1 0 1 1)
(concatenate 'list) =>  NIL

CL hat stringp string= string<=, ...

read koennte einen optionalen ersten string parameter als filename interpretieren und dieses file lesen
statt lispStdin, write sinngemaess, ggf. format und format-locale

primitives fuer Environmentvariables und -D Java Systemproperties. wenns nicht existiert, gibts nil, wenns nicht als
double lesbar ist, gibts NaN
primitives fuer isNan, oder konstanten NaN, Infinity und (eq d NaN)


JDBC vielleicht objectorientiert anbinden?
funktion nativequery bekommt eine datasource, einen SQL string und eine Liste mit (parameternameatom . wertexpression) tupeln

nativeinsert koennte fuer batchinserts eine Liste von listen mit (parameternameatom . wertexpression) tupeln bekommen und eine liste 
mit ints liefern (ein int für jede insert-tupel-liste)


http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node149.html
list-length could be implemented as follows:

(defun list-length (x) 
  (do ((n 0 (+ n 2))            ;Counter 
       (fast x (cddr fast))     ;Fast pointer: leaps by 2 
       (slow x (cdr slow)))     ;Slow pointer: leaps by 1 
      (nil) 
    ;; If fast pointer hits the end, return the count. 
    (when (endp fast) (return n)) 
    (when (endp (cdr fast)) (return (+ n 1))) 
    ;; If fast pointer eventually equals slow pointer, 
    ;;  then we must be stuck in a circular list. 
    ;; (A deeper property is the converse: if we are 
    ;;  stuck in a circular list, then eventually the 
    ;;  fast pointer will equal the slow pointer. 
    ;;  That fact justifies this implementation.) 
    (when (and (eq fast slow) (> n 0)) (return nil))))



isNaN, isInfinite, isFinite
-> ggf. parameter "Error bei NaN, Infinity etc."
div, remain, trunc, round, abs
weitere operatoren aus java.lang.Math (oder StrictMath?)

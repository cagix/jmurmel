kompilierte programme: MurmelProgram.body() kann man nur 1x laufen lassen, ab dem zweiten aufruf kommt "duplicate define"
-> alle globals am anfang von body() auf UNASSIGNED setzen
-> in lambdajbm erstmal labels statt defun

letrec im compiler ist fishy, laut langref sollten folgende variablen undefined sein, sind aber null


(compile) könnte in etwa so gehen:

kompilierter code muss lernen, freie variablen auch im environment des interpreters zu lesen und mit setq schreiben ((re-)define müsste so eigentlich auch gehen!),
   und interpretierte funktionen aufrufen (diese interpretierten funktionen müssen aber das environment des kompilierten codes sehen, und die Murmel funktion eval
   sollte ein gscheites environment mitbekommen, damit (eval '(lambda...)) aus dem compiler heraus funktionierende closures erstellen kann 
statt toplevelFormToJava() gibts eine andere funktion, es wird nicht das bisherige MurmelProgram geschrieben,sondern anders:
-> für jede freie variable gibts ein lambda, das sucht beim ersten zugriff mit assoc im environment des interpreters, und ersetzt sich selbst durch ein lambda,
   das bei künftigen zugriffen den wert aus dem environment eintrag ausliest
   -> zum zeitpunkt des ersten zugriffs können diese freien variablen existieren oder auch nicht (nur? globale variablen/ funktionen können später dazukommen)
   -> ob diese lambdas in die generierte klasse als member emitted werden müssen oder obs anonyme lambdas sein können?
      -> zum umpatchen brauchts einen namen. könnte aber statt lambda auch instanzen einer klasse sein, die hält das symbol und erst UNDEFINED und später den wert,
         und macht assoc on demand
-> diese klasse braucht also eine referenz auf das environment des interpreters zum zeitpunkt des aufrufes, und auch eine referenz auf den interpreter selbst
-> diese klasse sollte wsl. von MurmelJavaRuntime erben, da muss man halt den interpreter reinpoken statt neu erzeugen

freie variablen suchen/ schreiben und interpreter aufrufen wär bereits jetzt ohne (compile) nützlich, für eval.
-> mit eval kann man das ganze auch testen: eval erzeugt ein interpretiertes lambda, das dann vom kompilierten code aus aufgerufen wird

später könnte damit dann ein repl mit performance (durch compile) entstehen
-> compile in kompiliertem code aufrufen scheint auch nicht schwer, damit könnte man dynamisch neue kompilierte funktionen erzeugen

umsetzung: evtl wird aus MurmelJavaCompiler eine basisklasse, und abgeleitet MurmelJavaCompiler mit murmeltojavasource/class usw wie bisher, und abgeleitet
compilecompiler mit compile(LambdaJ intp, symbol oder ConsCell code, ConsCell environment)



compiler: (einige) forms die nicht in der tailposition sind (isLast == false) kann man eigentlich mit { forms... } schreiben, ergebnis wird ja nicht benötigt?!?
-> geht nicht innerhalb ?:, weil das braucht eine expression
-> emitForm müsste wohl einen parameter "expr" bekommen und geeignet durchreichen


errorMalformed könnte als ersten parameter ein enum Error übernehmen. das enum hat name und URL, es gibt enumwerte für alle special forms inkl "named let" usw. und "compilation unit".
damit könnte errroMalformed zusatzinfo wie "see http://.../murmel-langref.md#let" ausgeben.


im reader gibts every und some
-> woanders hin schieben?
-> every <-> and, some <-> or. kann man das woanders nutzen? in mlib?

wenn fatal in compiliertem code aufgerufen wird, kommt am ende
  history NOT run as Java - error:
die meldung ist falsch, weil gelaufen ists ja

(with-reader-printer (string string) forms...)
-> LambdaJ.pushReaderPrinter(Object, Object)/ popReaderPrinter() umsetzen
   String öffnet eine Datei, nil ändert nix, t setzt stdin/out

warum ist apply ein reserved word? sollte eine funktion sein
apply ist eine special form die sich wie eine funktion verhält, sollte aber eine funktion sein
-> umbauen wie eval?!?
-> eval auch umbauen, weil OpenCodedPrimitive ist unnötig, Object ocEval müsste reichen?!?
ausserdem: APPLY Forms as Places http://clhs.lisp.se/Body/05_abe.htm

ggf sollten nur t und nil reserved sein, der rest der bisherigen reserved words sollten nur bei zuweisung verweigert werden (setq, define, defun, letXX dynamic),
-> lambdalist, letXX, labels könnte zulässig werden
-> SBCL: (let ((t 1)) (write t)) gibt fehler, (let ((let 1)) (write let)) geht


GETTING STARTED löschen (auch aus jmurmel.github.io)?
samples aufräumen, ggf. gabriel nach samples.mlib, ggf. weitere gabriel programme dazu (mit plists?)


tests auf testng dataprovider umstellen
die test lispfiles auch kompiliert testen, v.a. wegen der fehlerfiles
einen unittest schreiben dass MurmelJavaProgram.getValue() alle predefined globals enthaelt

die methoden im compiler, die code ausspucken umbenamsen: emit...

statt überall "throw new LambdaJError(..."
-> funktionen errorArgcount(), errorMalformed(), errorInternal(), usw. einführen, erstmal werfen die eine exception
-> ggf. später statt exception optional einen handler aufrufen -> condition system
  -> solange exceptions geworfen werden, können die funktionen vom interpreter, compiler, compiler rt und generiertem code benutzt werden
     wenn handler gerufen werden, schauts anders aus 

read sollte am ende nicht nil liefern, sondern fehler oder übergebenes symbol

let* dynamic ändert globals für alle threads, sollte threadlocal verwenden



Platform matrix und publishing
https://github.com/actions/setup-java/blob/main/docs/advanced-usage.md#Testing-against-different-platforms

Dependency (security) checks mit maven:
https://github.com/jeremylong/DependencyCheck#maven-plugin


https://stackoverflow.com/questions/24487805/lambda-expression-vs-method-reference

compiler: tests für verschachtelte let dynamic
ggf. bei let dynamic als endcall zumindest warnen dass TCO nicht gemacht wird
ggf. für let dynamic statt try/finally eine restore liste basteln, und die wird irgendwie von tailcall abgearbeitet

teilweise gibts ringlistenerkennung (cdr(a) == start), das funktioniert aber nur bei listen, wo anfang mit ende verknüpft ist,
nicht aber bei einem loop mittendrin

options --pool-all-quoted-symbols, --pool-quoted-lists, --pool-quoted-lists-in-lists



Multiple values: VALUES, MULTIPLE-VALUE-BIND und MULTIPLE-VALUE_CALL müsste reichen?
VALUES hat als returnwert das erste argument, und verpackt ALLE (oder die restlichen?) argumente in ein Object[]
  und steckt dieses in eine globale variable (member von LambdaJ bzw. von MurmelJavaProgram).
MULTIPLE-VALUE-BIND und MULTIPLE-VALUE-CALL lesen das array wieder aus.
CLHS: VALUES -> funktion, MULTIPLE-VALUE-BIND -> special operator, MULTIPLE-VALUE-CALL -> special operator
SBCL: VALUES -> funktion, MULTIPLE-VALUE-BIND -> macro, MULTIPLE-VALUE-CALL -> special operator
VALUES kann auch in setf verwendet werden: (setf (values a b) (floor 7 2)), das ist aber in CL erst rel. spät dazugekommen,
  brauchts also nicht im ersten wurf
MULTIPLE-VALUE-BIND übernimmt nur eine VALUES form, MULTIPLE-VALUE-CALL übernimmt 0 oder mehrere
LIST-VALUES, VALUES-LIST, usw. sollten nur macros sein, die nur nice to have sind

vielleicht doch schon mal vector und svref implementieren? vector liefert eindimensionale arrays, 0-basiert, typ T. make-array könnte später kommen, das kann viel mehr
svref ist auch ein setf accessor
-> und char/ schar wären accessoren für strings...
   -> char kamma machen, setf/ schar geht nicht weil strings sind immutable
vielleicht auch list->svector und svector->list

funktion (error . args) ähnlich wie scheme: schreibt alle argumente mit (write arg nil) und dann (fatal)

(declaim (inline... implementieren
-> cdddr könnte inlined werden, dann würden die cdr aufrufe opencoded, und effektiv der ganze cdddr aufruf opencoded




 
gesondertes flag für setq, rplaca, rplacd? --no-mut
gesondertes flag für defmacro?
backquotes, append, assoc, assq



der interpreter könnte macros 1x expandieren und in den AST reinpatchen, und argcheck
für opencoded functions argcount check 1x machen und dann eine alternative funktion OHNE argcheck in den AST reinpatchen



(f 1 2 . l) könnte als flacher call verarbeitet werden: ". l" wird durch den inhalt von l ersetzt
-> kann man das kompilieren? wie?
-> müsste wohl nach (apply f (append '(1 2) l)) entzuckert werden
-> kompilieren ginge, aber eine macro expansion phase wäre wohl unmöglich,
   weil man erst nach der macroexpansion phase weiss, was die macroparameter sind.
   (apply macro...) geht aus demselben grund nicht
   -> man müsste dotted list für alle special forms inkl. makros verweigern,
      dotted list ist für application in den meisten lisps verboten, d.h. dotted list
      nur für function application zulassen wäre eine erweiterung, keine änderung
      (Murmel schluckt/ erlaubt aber stillschweigend dotted lists, behandelt sie wie proper lists)

wär hübsch für rekursiven aufruf einer varargs funktion:
(defun f (a b . c)
  (f a b . c)
-> eigentlich nicht nur für rekursive aufrufe sondern für alle aufrufe, wo eine vararg funktion ihre argumente wohinschicken will

-> im interpreter bräuchte man das wsl. nur in evlis einbauen?
-> und im compiler in funcall/tailcall zur laufzeit appenden? und in opencode!
   -> vielleicht doch besser desugar?
-> aufpassen, dass nicht (f a b) 1x argumente evaluiert und (f a . b) 2x

vielleicht müsste es auch sein: (f a b . l) <=> (apply f (append (list a b) l)). oder einfacher: (apply f (list* a b l))


müssen die compiler rt funktionen public sein oder reicht protected? geht static?
-> static würd gehen, protected nicht wg. Java compiler fehler
-> import io.github.jmurmel.LambdaJ;
   in getValue(): case "sleep": return (CompilerPrimitive)this::sleep;
                  -> case "sleep": return (CompilerPrimitive)MurmelJavaProgram::sleep;
   in extenvprim(): rt() -> LambdaJ.MurmelJavaProgram

die wellknown symbols (special forms wie let & co, und opencoded functions)
werden static final und in eine static final liste gesteckt,
eine neue symboltable fängt nicht bei nil an sondern bei eben dieser static final liste (nur die interned strings)
damit kann der interpreter (und evalOpencode) auf switch umgestellt werden.
weiterer vorteil: mehrere LambdaJ instanzen sharen die wellknown symbols
-> funkt aber nur mit LambdaJ symboltable, wenn man eine eigene nimmt, weiss die nix von diesen symbols

feature headless und ggf gui
-> nein, features sollten nicht erst zur laufzeit ermittelt werden?
   -> besser: funktion headlessp
MAVEN_OPTS=-Djava.awt.headless=true und dann turtle-funktionen in murmel-langref wieder aufdrehen?

Graalvm download: https://github.com/graalvm/graalvm-ce-builds/releases
native executable bauen: https://github.com/clj-easy/graalvm-clojure/blob/master/doc/clojure-graalvm-native-binary.md

Adopt OpenJDK 8u (alt): https://adoptopenjdk.net/upstream.html?variant=openjdk8&jvmVariant=hotspot
Adoptium OpenJDK 8u (Nachfolger): https://adoptium.net/?variant=openjdk8&jvmVariant=hotspot

SRFI 197 hat chain operator & Co, siehe https://srfi.schemers.org/srfi-197/srfi-197.html
ähnlich wie ->

"inline java" könnte man (im compiler) in etwa so machen
(java (a b c) "return a + b + c;")
-> (MurmelFunction)(args) -> { /*argCheck(args.length, 3);*/ Object a = args[0]; Object b = args[1]; Object c = args[2]; return a + b + c: }


https://www.reddit.com/r/scheme/comments/somz8y/tail_calls_for_native_targets/
https://github.com/edn-format/edn ist so ne art erweiterte S-expressions spec

mit Class.forName() könnte man eine Klasse mit Custom Primitives laden.
-> der bestehende customenvironment trick geht eh nur im interpreter?!? wär dann nicht mehr nötig
Class.forName() könnte auch absplitten des Compilers in eine andere Klasse ermöglichen, dann würde das verbleibende LambdaJ immer noch als single source file funktionieren

(asynclet threadpool-symbol ((sym form)...) forms)
-> die binding-forms würden asynchron in threads laufen, sym wäre ein promise, innerhalb forms würde sym ggf. blockieren
-> threadpool kann normale threads oder loom threads liefern, nil wäre irgendein defaultpool

Lisp Quine: https://de.wikipedia.org/wiki/Quine_(Computerprogramm)
JMurmel> ((lambda (x)
  (list x (list (quote quote) x)))
 (quote
    (lambda (x)
      (list x (list (quote quote) x)))))

==> ((lambda (x) (list x (list (quote quote) x))) (quote (lambda (x) (list x (list (quote quote) x)))))

oder (stimmt nicht ganz): (define s "(define s %c%s%c) (format t s #\" s #\")") (format t s #\" s #\")
ergebnis:                 (define s "(define s %c%s%c) (format t s #" s #")") (format t s #" s #")

oder: (define s "(define s %c%s%c) (format t s (code-char 34) s (code-char 34))") (format t s (code-char 34) s (code-char 34))



mit optimize speed 0 und 1 testen



der reader könnte die erste zeile fressen wenn sie mit #! beginnt, siehe auch https://srfi.schemers.org/srfi-22/

mit -Djava.awt.headless=true gibt (make-frame) eine HeadlessException
-> ggf. eine funktion um einen frame in eine datei zu schreiben? und headlessp
   und bei headless erstellt make-frame nur linecomponent, d.h. alles geht auch headless bis auf open-frame

trace sollte das symbol tracen. in der map steht aber die adresse der funktion, die ändert sich bei load oder re-defun,
und es wird nicht mehr getraced

rplacd für ArraySlice ist problematisch: man könnte ins array an der richtigen stelle was anderes reinpatchen,
aber wenns andere arrayslices mit demselben array gibt (mit anfang NACH der rplacd stelle), dann wirkt sich rplacd
auf die anderen ArraySlices ggf. nicht richtig aus

compiler: alle defuns/ defines, nicht nur toplevel
-> zähler mitlaufen lassen
   im pass1 alle gen-methoden mit zähler als suffix generieren
   im pass2 zähler erneut hochzählen und die entsprechende zuweisung generieren
   -> achtung bei macros
-> das brauchts z.b. wenn makros define enthalten
-> und/ oder makros pro toplevel form expandieren, toplevel progn auch

(re-) define im compiler
-> oder doch nicht? braucht man hauptsächlich im REPL



assert, error: https://google.github.io/styleguide/lispguide.xml?showone=Assertions_and_Conditions#Assertions_and_Conditions
function error: http://clhs.lisp.se/Body/f_error.htm
macro assert: http://clhs.lisp.se/Body/m_assert.htm

warum ist assoc in jmurmel drin?
-> assoc, rassoc in mlib jeweils mit optionalem predicate (rassoc ist reverse lookup, sucht statt im car im cdr)
-> assoc-if, rassoc-if
-> support für plists (ähnlich alists aber alist hat tupel, plist hat abwechselnd key und value in einer flachen liste plus eq statt eql),
   symbol-plist wäre optional auch möglich (und get, getf, ...). get verarbeitet symbol plist, getf verarbeitet alleinstehende plists
https://gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html

car und cdr auf strings und symbols macht nur probleme
-> (list-length '(a . b)) -> 3 !?! sollte fehler geben
-> ist auch blöd zum opencoden

sollte defmacro eine neue definition pushen und (defmacro n) die vorige wieder herstellen?

alte define syntax zusätzlich unterstützen:
(define ((a 1) (b 2))) ???

interlisp hat
(DEFINEQ
  (DESTRUCTIVE
    (LAMBDA  (n  m)

https://stackoverflow.com/questions/7872852/map-filter-foldr-in-drracket-scheme
https://stackoverflow.com/questions/36960124/foldr-and-foldl-in-drracket
https://srfi.schemers.org/srfi-1/srfi-1.html, https://srfi.schemers.org/srfi-1/srfi-1-reference.scm


Scheme Benchmarks:
https://ecraven.github.io/r7rs-benchmarks/


communicating sequential processes (CSP) ist im prinzip die channels von go, siehe https://en.wikipedia.org/wiki/JCSP
siehe auch https://github.com/hawkir/calispel

https://github.com/stassats/swank-gauche ist ein swank server für gauche,
kamma vielleicht einen swank server für jmurmel abkupfern?!?
siehe auch https://github.com/astine/swank-client/blob/master/swank-description.markdown

#. form
-> form wird zur read zeit ausgewertet

https://github.com/sbcl/sbcl/blob/master/.github/workflows/windows.yml
-> sbcl baut bei jedem push einen windows installer, der liegt dann als artefact beim workflow run, z.b. auf 
   https://github.com/sbcl/sbcl/actions/runs/1034569455

j.u.l logging iwie anbinden?

mapXX vielleicht so umbauen, dass auch dotted lists erlaubt sind?
-> oder zusätzlich mapXX*?
sollte apply eine dotted list akzeptieren?
-> oder apply*?
&+ liefert bei integer args die summe als integer mit 2s complement wraparound, auch &- &*
-> oder +&, -&, *&, ggf auch /& für div
    -> Swift hat anscheinend &+, &*, &<<, etc.



java interop:
-> siehe https://clojure.atlassian.net/browse/CLJ-2365 und https://clojure.atlassian.net/browse/CLJ-2637
Primitive und CompilerPrimitive könnten passende Java interfaces implementieren,
  z.b. Callable, Runnable, Supplier, Consumer, Predicate, defuns und lambdas ebenso
-> vielleicht sollte Primitive, CompilerPrimitive, MurmelFunction einfach diese interfaces erweitern, und die jeweiligen Methoden sind default methoden die auf murmelcode delegieren
   Predicate.test(T) implementieren als apply(Object[0]) != null usw., wenn arity nicht stimmt (also der murmelcode will args) dann gibts eh automatisch einen rt error

parenscript (das ist eine empedded sprache CL -> Javascript) hat die funktion oder makro "chain"
(chain console (log my-list)))) -> console.log(myList)
-> eine ähnliche funktion/ special form könnte Java direkt in den generierten Code injecten

CL+J ist ein CFFI Binding CL nach Java: https://common-lisp.net/project/cl-plus-j/
CL+J is a JNI based interface to a Java Virtual Machine through CFFI. It targets safe, exact and complete access to Java 
from Common Lisp with as high integration as possible of the Java and CL respective runtime environments 
(especially at the condition/exception level).
CL+J uses a set of reader dispatch-macros to simplify the Java code interface. In CL+J the traditional "Hello World!" becomes:
  (#_System.out.println (jstr "Hello World!"))



https://www.reddit.com/r/ProgrammingLanguages/comments/nsktgu/i_built_a_lisp/h0uadn4/
For your error handling, implement two things:

    1 Some sort of non-local jump mechanism that allows you to "return" from arbitrary points on the stack.
    2 Have the interpreter call a designated function whenever an error occurs. As far as your interpreter is concerned,
      "error handling" just means calling the error handling function, without unwinding the stack or doing anything special.
      By #1, the error handler can "return" from the original expression that triggered the error.

With those building blocks, you can implement the equivalent of Common Lisp's condition and restart system entirely in Lisp.
If you make it possible to inspect the stack from Lisp, you also gain the ability to write a debugger in Lisp.
https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html



--add-feature
-> z.B. jm --add-feature test
   -> damit kann man tests per feature expressions ein/ ausschalten

im repl: rplaca, rplacd, setq veraendert die history (die aus conses besteht)
-> :r fuehrt was anderes aus als der interpreter davor

as... konsequenter einsetzen statt numberArgs wenns nur um ein arg geht

macros haben mlib nicht zur verfügung oder doch?
-> checken, ggf. entweder ändern oder dokumentieren
   -> im interpreter sehen die macros defuns, im compiler nicht, weil der compiler das interpreter-eval aufruft

ein eigener macro namespace ist schlecht: zum ueberschreiben muss man wissen, obs ein macro oder eine funktion ist
-> gibts ein macro "m" dann hat "(defun m..." keine auswirkung
-> vielleicht so lassen und defun für ein macro verbieten, so wie defun für special forms verboten ist?

funktion error (und/ oder exit) wirft eine exception die am programmende den errorlevel bestimmt
         fatal wirft eine exception die am programmende den errorlevel bestimmt plus fehlermeldung mit murmelstack
mlib-test vervollständigen

filenamen in fehlermeldungen

sollte mlib equal einen fallback nach Objects.equals() haben?



einige samples:
JMurmel> (->> (mapcar print 'abcde) reverse list->string)
#\a
#\b
#\c
#\d
#\e
==> "edcba"

JMurmel> (->> '(0 1 2) print (mapcar 1+) print (mapcar (lambda (n)(expt n 2))) print (reduce +) round)
(0 1 2)
(1 2 3)
(1.0 4.0 9.0)
==> 14

JMurmel> (mapcar (lambda (n) (prog1 (-> n princ (->> 1+ 1+) princ (expt 2) round princ) (terpri))) '(0 1 2 3 4 5))
024
139
2416
3525
4636
5749
==> (4 9 16 25 36 49)



globals koennten eine hashmap sein?!?

http://www.ulisp.com/show?37VY hat ein einfaches objekt system
vgl. Graham, Paul "On Lisp"  Prentice-Hall, New Jersey, 1994, pp. 348-379, available online at http://www.paulgraham.com/onlisptext.html.
siehe auch http://forum.ulisp.com/t/a-simple-object-system-for-ulisp/622

; makes jmurmel crash with java.lang.StackOverflowError
(defun f names
  (if names
        (cons (car names) (f (cdr names))) ; this line should be "(cons (car names) (apply f (cdr names)))"
    nil))
-> stackoverflow ist wsl ok, sollte aber in eine Murmelfehlermeldung umgelenkt werden



https://www.reddit.com/r/lisp/comments/lxlyvb/why_does_cl_have_such_a_strange_way_of_obtaining/gpo0swr/
it is undefined behavior according to the ANSI spec to redefine a standard function
-> car cdr cons koennten im interpreter open coded sein zwecks performance

symbolhandling ist fishy
-> symbole sollten nicht per stringvergleich sondern ueber identity verglichen werden
  -> dadurch wirkt sich der unterschied interned/ nicht interned nicht wie gewuenscht aus, und gensym funktioniert nicht richtig
-> der reader sollte symbole auf UC stellen (ausser ||), symboltable sollte case sensitive sein
(erl) -> compiler sollte nicht stringvergleich machen

gensym im compiler (momentan gehts nur in macros)

1\234 sollte als symbol gelesen werden


Macros im compiler
-> http://clhs.lisp.se/Body/m_defmac.htm:
-> If a defmacro form appears as a top level form... Users must ensure that the body of the macro can be evaluated at compile time if it is referenced within the file being compiled.

init(), parser vs. in aufraeumen




...jdk-15\bin\jlink --output jm --compress=2 --no-header-files --no-man-pages --strip-debug --add-modules java.base,jdk.compiler,jdk.zipfs
-> das baut anscheinend ein ca. 30MB grosses JRE mit den Java Modulen, dies fuer JMurmel braucht
-> jdk.localedata noch dazu?

obiges hab ich experimentell ermittelt, jdeps sollte exakte aussagen treffen;
...\lambda>jdeps --print-module-deps target\jmurmel.jar
java.base,java.compiler,java.desktop,java.management
-> jlink --output jm --compress=2 --no-header-files --no-man-pages --strip-debug --add-modules java.base,java.compiler,java.desktop,java.management
-> da ist aber kein compiler dabei



cmdlineflags wos let aber nicht letXXX oder ggf named let gibt
-> --no-scheme, auch null? und ggf if abdrehen
-> dann gibts nur mehr not bound, kein undefined value


vielleicht --jar und --fatjar: --fatjar erzeugt ein jar, das auch die rt enthaelt

packages koennte man mit namenspraefixes umsetzen, und bei einer symboltabelle/ einem environment bleiben.
laesst sich dann auch sehr einfach auf Java packages/ klassennamen umlegen

compiletojar, tojava, ... sollten eigentlich in der Sprache angeboten werden
-> erst mit packages, weil dann brauchts weniger parameter

--srcjar option: die sourcen dazuzippen? oder extra srcjar?

ConsCell: methoden rplaca und rplacd, jeweils fuer die subklassen geeignet umsetzen: rplacd bei zwei IntArraySlices koennte die arrays in ein groesseres hintereinanderkopieren
-> erstmal nicht in der sprache anbieten, spart aber einige casts v.a. in den tests
-> und nth und nthcdr, anschliessend caaar, cdddr, ... mit nth bzw. nthcdr implementieren
-> achtung: es koennten mehrere ArraySlices auf das selbe array zeigen.
   -> Vor naiv implementiertem rplacd: alle ArraySlices zeigen auf die gleichen daten,
      aenderung ueber ein slice ist in den anderen sichtbar
   -> nachdem ein ArraySlice das array durch ein anderes ersetzt hat: slices zeigen auf verschiedene daten,
      anderungen ueber ein slice sind NICHT mehr in anderen sichtbar-> FEHLER
   -> rplacd ist nur fuer ListConsCell umsetzbar, nicht fuer ArraySlice, rplaca wuerd wsl gehen

Den Compiler retargetable machen: methoden die Code ausspucken nach emit... umbenamsen und in eine klasse zusammenfassen, es koennte mehrere solche klassen
fuer mehrere zielsprachen geben, formsTo... bekommen so eine instanz als parameter
oder visitor pattern?


ConsCell.iterator() ueberladen: iterator(typ) liefert verschiedene iteratoren:
circular list liefert nach der ersten runde hasNext() == false
                                            fehler
dotted list liefert beim zugriff auf letztes element letztes element das element
                                                                     hasNext() == false, hasNext(true) liefert das letzte element
                                                                     fehler
sowohl mapcar wie auch maplist zulassen: der iterator liefert entweder nth(cursor++) oder nthcdr(cursor++)


trace und features refactoren:
nicht int features sondern Set<Features>
statt trace >= TRC_XXX.ordinal -> methode TraceLevel.ge(TraceLevel)

anzahl parameter duerfen begrenzt werden, auch bei varargs
-> hilft bei cdr(arg) im compiler, umsetzen, dokumentieren, global mit dem wert erfinden, vgl. http://...

funktion compile, und dem interpreter beibringen, wie kompilierte funktionen aufgerufen werden, und/ oder Primitive auf MurmelFunction umstellen
-> erst CPS im compiler umsetzen

IntArraySlice, CharArraySlice, ...
string->array koennte so ein CharArraySlice liefern, readbytes koennte ein ByteArraySlice liefern
nth und nthcdr in ConsCell rein, fuer alle subklassen geeignet umsetzen
cdddr sollte als nthcdr(3) umgesetzt werden, caaar als nth(3), caddr als car(nth(2)) usw., dann waeren die ArraySlices effizienter
readObj koennte ArraySlice liefern, wenn eine sexpression mehr als X member hat, vielleicht als pratt parser umsetzen?
-> dann gibts aber keinen platz fuer zeilennummern, also ggf einen gesonderten reader zum lesen von stdin basteln



https://github.com/phoe/cafe-latte
CL conditions
dynamic variables
tagbody go
block/return-from
restart
-> block/return-from koennte wsl mit "label: for (;;) break label;" umgesetzt werden (plus das richtige result setzen)
-> tagbody/go koennte wsl mit "label: for (;;) continue label;" umgesetzt werden
-> beides wird in Java lambdas nicht gehen, ggf. im lambda "throw ..."


zeilentabellen lisp->java mitfuehren und ins java verpacken? dann koennte ein catch im main() den stacktrace umschluesseln
-> javacode sollte mehr linefeeds bekommen
-> javaassist kann linenumbertable fuer methoden neu setzen, die enthalten sourcefile und sourcezeile
-> apache bcel wsl auch, bcel ist in java mitgepackt: com.sun.org.apache.bcel

wenns namespaces gibt, sollte :: wahrscheinlich i-wie mit import verheiratet werden

vielleicht doch nil=null und t=Boolean.TRUE? Interpreter ggf. angleichen

refactor: alles was zum interpreter gehoert in eine neue Klasse LambdaJ.MurmelInterpreter heben
-> auf gleichem Level wie LambdaJ.MurmelJavaCompiler und LambdaJ.MurmelJavaProgram
-> dann koennten Interpreter und Program das gleiche Interface fuer getValue(), getFunction() haben
-> runtime aussen vor lassen? oder es gibt methoden die implementieren z.B. write, und getrennte wrapper fuer interpreter und kompilierte programme

im environment des compilers koennt man den typ der symbole mitfuehren, das wuerde compiletime typchecks ermoeglichen.

das main von compilierten programmen sollte am ende ggf alles abbauen. vielleicht eine methode dazu, die auch exposed ist? interpreter auch?
oder macht das der gc, wenns keine referenz auf das kompilierte programm/ den interpreter mehr gibt?

compiler:
-> irgendwie alles (lambdas, letXXX, labels, ...) in eine funktion (Object[] args, var Function next) -> Object verpacken
-> next kann ggf. von der funktion woanders hin gebogen werden (fuer continuations)
-> ohne continuations: lambda ggf. vorerst nicht aendern sondern per apply(Function, params, next) ausfuehren lassen
-> mit continuations: eine continuation ist statt normalem lambda: (Function continuation, Object[] args, var Function next) -> Object
    -> die continuation kann "continuation" in next reinstecken, dann wird "continuation" als naechstes ausgefuehrt statt "next"
-> body hat dann einen loop, der die funktionen der reihe nach aufruft, jeweils das gelieferte "next" ist die naechste funktion
-> statt var parameter koennen funktionen auch ein tupel (Object, Function) als result liefern

-> kann man eigentlich im interpreter gleich machen

Tracer bei JSR-223 nutzen.

irgendwie mit maven von Murmel nach Java uebersetzen, dann kann man einen teil einer app in murmel schreiben und fast nahtlos von Java aufrufen
-> https://stackoverflow.com/questions/2147115/generating-sources-by-running-a-projects-java-class-in-maven

in C gibts #pragma line, das schreibt debug infos ins Object file. gibts in Java annotations und einen processor, der dasselbe macht?
-> debuggen von kompilierten murmel programmen

anstatt letXX, cond im compiler auszuprogrammieren, kann man auch desugar programmieren, idealerweise als macroexpander
-> desugar ist macroexpand mit zus. macros fuer let-> lambda usw.
-> stattdessen kann man ggf. cons, car, cdr, +, - usw inlinen (aber erst schauen ob das was bringt)

die generierten programme koennten ein cmd arg "--repl" unterstuetzen: mit dem arg gibts nach body() kein exit() sondern repl()

filevariablen statt der gefaehrlichen cmdline args

JSR223 vielleicht in ein zweites jar verpacken?





tests von lis.py verpacken

eval, interpretExpressions & Co aendern:
- einige init methoden die setzen in, out, environment, symboltable
- eine methode eval(ConsCell progam), das ist ein wrapper um das bisherige eval, der wrapper schmeisst eine exception falls nicht
  initialisiert.
- die sprache ist ja eine liste von ConsCells, mit so einem API waers ggf. einfacher/ natuerlicher einen anderen Parser davor
  zu schalten
- das derzeitige eval kann nur eine expression, listen arbeiten repl() bzw. interpretExpressions() ab. Obiger eval wrapper
  sollte auch listen koenen



current-cc ist eigentlich immer cdr(form)
-> bzw. cons(cdr(form), current_cc) oder append?!?
        -> und wie baut man das environment wieder ab?
            -> statt cons-> cons3(cons3(cdr(form), current_cc, newScope), env)?
        -> und wie uebersetzt man das nach java?
   damit koennt ma continuations umsetzen, und eval waer ueberhaupt nicht mehr rekursiv, statt return-> form=current_cc; continue;
   -> das waer dann "compile with continuations", continuations kann man muss aber nicht in der sprache anbinden



vielleicht eval irgendwie umbauen, dass ein symbol nicht den wert sondern den enventry liefert? das waer dann ein lvalue,
und wuerde ein allfaelliges setf ermoeglichen. (get-record recordsymbol propertysymbol) wuerde dann auch ein (symbol . value)
tupel liefern, und dann wuerd (setf (get-record my-record propertysymbol) value) gehen
eigentlich muesste das nur in eval->symbol und zip eingebaut werden



Objektorientierung: records (default immutable) und "methoden" ala go (wenn eine funktion als ersten parameter einen recordtyp uebernimmt)
(defrecord mutable? symbol (extends...) symbol...) -> symbol ; eigener namespace fuer records? feldsymbols haben automatisch eigenen namespace, weil sie in einer hashtable des records drinstehen ?
(make-record mutable? recordsymbol (propertysymbol value)...) -> record
(get-record recordform propertysymbol) -> value
-> unions auch reinzwicken? z.B.
   (defrecord mutable? symbol (extends...) propertysymbol-oder-unionsymbol+(propertysymbol...)...)
   -> ohne typen fuer die properties wird das wohl zu kompiziert, und java hat auch keine unions
      ohne typen sind unions auch nicht notwendig, weil man kann einem symbol verschiedene records zuweisen

methoden, also funktionen die nur fuer einen bestimmten recordtyp zutreffen, kann man machen, muss man aber nicht

vielleicht die recordnamen in den selben namespace geben wie double, integer, string (die noch keinen haben)?




tabs im scanner richtig zaehlen
col += tabsize
col = (col / tabsize) * tabsize



koennt ma namespaces irgendwie so einfuehren:
namespace xxx biegt topenv woandershin
define schreibt nicht in topenv sondern ins package
export schreibt ins topenv
import kopiert (symbol . value) entries aus einem anderen env ins aktuelle
assoc sucht erst im aktuellen namespace, dann in topenv (wie spielt das mit den gestapelten environments zusammen?)
-> namespaces nach C oder object files waeren irgendwie C und H files bzw getrennte object files - export schreibt ins .h file
   bzw exportiert das symbol aus dem object file





Vielleicht in define den Lisp Code nach Java uebersetzen und mit tools.jar uebersetzen? Und aus dem erzeugten class file
ein neues primitive basteln?
-> denkbar waere ein aeusserer und ein innerer compiler. der aeussere uebersetzt nach java/c/..., der innere nach bytecode
-> vor dem compiler koennten transformationen laufen wie z.b. let->lambda, dann brauchte der compiler und eine allfaellige vm
   nicht so viele features haben
   -> oder der (bytecode) compiler erzeugt code der nur weniger vm features braucht



define sollte das aktuelle environment erweitern, nicht das globale
zusaetzlich define-global einfuehren (ist das dasselbe wie defconst? solange keine re-definition und kein set -> ja)
-> oder auch nicht: Scheme define != Old Lisp define





neuen parser: (evtl while, for (list) umsetzen?)
program ::= stmt*

stmt ::= exp ';'

exp ::= assignment | lambda | case | block | application

assignment ::= s '=' exp
-> (define s exp)

case ::= 'case' (exp block)* 'esac'
-> (cond (exp block))

block ::= '{' stmt* '}'
-> (progn explist)

lambda ::= function(p1, p2) block   		; implicit symbol 'self' for recursion
-> (lambda (p1 p2) stmt*)

application ::= builtin | f(exp1*)			; add, sub, ..., pair, list 
-> (f explist)

(e1, e2)
-> '(e1 e2)

atomexp ::= atom
-> atom


builtin:
pair(exp1, exp2)
-> (exp1 . exp2)

list(exp1, exp2, exp3)			; list(exp*)
-> (list exp1 exp2 exp3)

add(1, 2)
-> (+ 1 2)



ConsCell methoden double carAsDouble(), long carAsLong() einfuehren
-> und DoubleConsCell, LongConsCell, das hat zusaetzlich Java primitive datentypen als car und ueberlaedt die methoden

multivalue let: wenn funktionen mehrere werte zurueckgeben, koennte ein erweitertes letXXX zuweisen:
(let ((r1 r2 (multivaluefunction)))
   (print r1)
   (print r2))
-> gibts schon in scheme




printSEx: if (car(list) == sQuote) print "'" + printSex(cdr(list))
der reader sollte wsl ' immer auf (quote... umsetzen, egal ob quote unterstuetzt wird oder nicht

umbenennen:
lispStdout -> lispPrinter
ObjectReader -> LispReader, #readObj -> #read
ObjectWriter -> LispPrinter, #printObj -> #print


synchronized ueberlegen





solange es kein rplaca gibt, koennte man int, float, double und ggf kurze/ lange strings/ symbols in jeweils massgeschneiderte ConsCell stecken
-> muesste sehr hohe speichereinsparung und performanceverbesserung bringen
sollte es rplaca geben, muesste dieses logik haben, um bei typaenderung in ein neues ConsCell umzukopieren und dieses ggf. einzuhaengen
-> oder typaenderungen sind verboten
-> oder man kann optional einen typ angeben, dann ists schnell und der typ ist fix, ohne typangabe ists langsam aber der typ darf sich aendern
z.B. statt
(lambda (a b) (...))
(lambda (integer a double b) (...))
 

nach bytecode compilieren: der bytecode wird dann in einem threaded interpreter abgearbeitet
der interpreter sollte wsl direkt in eval drinstehen wg. TCO. der threaded interpreter kann
direkt cons, car, cdr, +-*/ usw. ist sonst aber sehr aehnlich dem interpreter-eval.
die threaded interpreter "methode" bekommt environment
und ein int (oder char? eher byte[]) array mit bytecode und arbeitet den bytecode ab:
char[] code; XXX env;
int ip = 0;
top:
while (ip < code.length) {
switch (code[ip++]) {
case car: extendenv(...; continue top;
case cons: extendenv(new ConsCell(...; continue top;
}

ggf. auch in den interpreter einige funktionen wie +/- "inlinen"





Speicherverwaltung selber machen in Java oder C:

Der Heap ist ein Array int[], 2 aufeinander folgende elemente sind ein cons
allokation ist bump allocation. ist der zaehler == array.length muss das array in ein neues groesseres array umkopiert werden
die ints werden als bitmasks interpretiert:
  die niedgristen 3 bits sind der variablen typ (d.h. 8 typen moeglich)
  intwert >> 3 ist der wert:
    pointer: ein index ins array
    symbol: ein index in die (getrennte) symboltabelle
    number: die zahl
    usw.

statt 3 bits koennten mehr oder weniger verwendet werden, wird die max anzahl cons zells groesser oder kleiner
in C koennten (muessen aber nicht) Pointer wirkliche Pointer statt indizes sein, wuerde eine indirektion sparen,
  diese muessten beim realloc des arrays (i.e. heap vergroessern) aber angepasst werden
optionales GC waer moeglich, in C und in Java, oder man laessts weg fuer kleine programme
generational heaps waeren auch moeglich, dann muesste es verschiedene pointertypen geben, jeder typ zeigt in einen anderen heap
das ergebnis einer expression koennte aus dem Heap (der auch garbage enthaelt) rausextrahiert werden, indem man wie ein GC dem root folgt,
  das ergebnis ist dann ein array das kleiner ist als der heap, also der GC komprimierte Heap

das waer alles in einer Klasse Heap { cons(); car(); cdr(); } abstrahierbar, nur die klasse kennt ConsCell
-> interface ConsCell waer moeglich. beim ArrayHeap sieht ConsCellImpl so aus:
ConsCellImpl {
    ConsCell(int n);
    Object car() { return get(n); }
    Object cdr() { return get(n+1); }
    Object get(int n) {
        int type = heap[n] & 1<<3;
        int value = heap[n] >> 3;
        switch (type) {
        case integer:
        case pointer: return new Integer(carvalue);
        case symbol: return symtab[carvalue];
        case float: // Float#intBitsToFloat benutzen, vgl NaN trick in Lox
        }
    }
    rplaca(newVal)...
    rplacd(newVal)...
}

ohne variablenzuweisungen braucht man eigentlich keinen gc und kein refcounting, einfach beim return
"alles freigeben, was nicht im returnvalue steckt" ?!?
-> so wirds wohl rust machen, plus borrow checker
-> "alles freigeben, was nicht im returnvalue steckt" ist aber nicht so leicht



einen debugger in eval einbauen? expression fuer expression? und/ oder eine special form break? :break symbol?

flag ob die identifier auf UC umgestellt werden sollen
flag fuer symbols:
--symbols=uc ... symbole werden beim lesen auf UC umgestellt
--symbols=ci ... symbole werden nicht umgestellt, aber case insensitive verglichen
--symbols=cs ... symbole werden as is verwendet, case sensitive verglichen

Vielleicht doch set/setf/setq, vgl ABOUT LISP https://graham.main.nc.us/~bhammel/graham/lisp.html
rplaca, rplacd
Vielleicht ein "Imperative Paket" mit flags ein/ausschalten?

        if(car(exp) == s_define)                        // "define"
          return(extend_top(car(cdr(exp)),
                            eval(car(cdr(cdr(exp))), env)));
        if(car(exp) == s_setb) {                        // "set!"
          obj *pair   = assoc(car(cdr(exp)), env);
          obj *newval = eval(car(cdr(cdr(exp))), env);
          setcdr(pair, newval);
          return newval;
        }

am besten setf weglassen, weil das macht serious magic
-> set ... belegt den ersten gefundenen wert im environment neu. dynamic, lexical, global, halt dort, wos assoc zuerst findet
           beide argumente werden evaluiert
-> setq ... wie set aber das erste argument wird nicht evaluiert
-> rplaca, rplacd http://clhs.lisp.se/Body/f_rplaca.htm
   rplaca cons object => cons
   rplacd cons object => cons





LambdaJString.value von String auf char[] umstellen?
-> wuerde ggf. builtins rund um java.lang.Character erleichtern
-> char ist 16 bit
-> Java11 speichert String.value nicht als char[] sondern byte[], diese Speicherersparnis waer dann verloren



In einer LISP Datei nach dem Ende einer Toplevel form koennten Daten stehen, die wuerden von read gelesen
-> Beispiel machen
LambdaJ> (write (read)) "Hello, World!"
"Hello, World!"
==> t





Generic S-Expression reader/ writer: (<n>:<octets>)

// Files can be loaded into the REPL
scala> :load /sites/repl-test.scala
Loading /sites/repl-test.scala...
res2: Int = 4
res3: Int = 6

-> vielleicht :save und (load <string>)


builtin oder special form fuer try/catch:
try = (lambda (func catch-handler finally) (
  try { return func(); }
  catch (Exception e) { return catch-handler(e); }
  finally { finally(); }
)





cadr, caddr, cadar, cddr, ... in eval verwenden und schauen, wieviel kleiner eval wird
-> solche primitiven wuerden auch Lisp programme schneller machen weil weniger assoc aufrufe
-> ein optimizer, der in define oder lambda reingezwickt wird, koennte (car (cdr o)) erkennen und durch (cadr o) ersetzen
   mit rekursivem abstieg muesste man nur current node und naechste stufe betrachten
   car/car  -> caar
   car/caar -> caaar
   car/cadr -> caadr
   car/cdr  -> cadr
   car/cdar -> cadar
   car/cddr -> caddr

   cdr/car  -> cdar
   cdr/caar -> cdaar
   cdr/cadr -> cdadr
   cdr/cdr  -> cddr
   cdr/cdar -> cddar
   cdr/cddr -> cdddr

beispiel, wie man einen logger einhaengen kann.

LambdaJError extends RuntimeException   ... abstract
Syntaxerror extends LambdaJError        ... nur eval
RuntimeError extends LambdaJError       ... nur primitives

k.a. wieviel die ConsCell casts bremsen
Alternatives Objectmodell mit weniger casts:

interface Value {
    default car() { throw new Error("not a cons"); }
    default cdr() { throw new Error("not a cons"); }
    String toString();
}

interface Atom extends Value {
    Object value;
    String toString() { return value.toString(); }
}

class ConsCell extends Value {
    Value car, cdr;
}

Value car(Value v) { return v.car(); }
Value cdr(Value v) { return v.cdr(); }
ConsCell cons(Value car, Value cdr) { return new ConsCell(car, cdr); }


nice to have: apply mit zuviel/ zuwenig args fuer ein lambda: ueberschuessige args koennten gemeinsam mit dem letzten als liste uebergeben werden,
fehlende als null.


Doku: ein Custom Parser koennte statt parsen eine Liste liefern (koennte z.B. hardcodiert
mit new ConsCell zusammengestoppelt werden) und intern() koennte mittels String.intern() umgesetzt werden.
Anmerkung: Symbols sind Strings, Stringliterale in der o.a. Liste sind bereits mit String.intern() bearbeitet,
  dazu passt die Umsetzung der Parsermethode intern() mittels String.intern()
Anmerkung 2: Lisp Strings werden als LambdaJString repraesentiert
Anmerkung 3: intern() mit einer HashMap waer auch nicht schwer


Doku: https://en.wikipedia.org/wiki/Peano_axioms enthaelt natuerliche Zahlen basierend auf Mengen,
koennte eine Anleitung sein, wie man Zahlen in einem Lisp ohne Zahlen umsetzen kann
0 = nil
1 = succ(0) = '(0) = '(nil)
2 = succ(1) = '(0 1) = '(nil (nil))
3 = succ(2) = '(0 1 2) = '(nil (nil (nil)))

addition:
(add (a b) (if (null? b) a (add '(nil a) (cdr b))) ; oder so aehnlich

multiplikation:
(mul (a b) (if (null? b) nil (add a (mul a (cdr b)))) ; oder so aehnlich


Clisp:
(setf zero ())                                ; -> zero = NIL

;(define (cons a b) (lambda (f) (f a b)))      ; define?
;(define (car c) (c (lambda (a b) a)))         ; define?
;(define (cdr c) (c (lambda (a b) b)))         ; define?

(defun succ (a) (cons zero a))                ; das geht

(setf one (succ zero))                        ; -> one = (NIL)
(setf two (succ (succ zero)))                 ; -> two = (NIL NIL)
(setf three (succ (succ (succ zero))))        ; -> three = (NIL NIL NIL)
(setf four (succ (succ (succ (succ zero)))))  ; -> four = (NIL NIL NIL NIL)

(defun add (a b) (if (eq b zero)
                     a
                     (add (succ a) (cdr b))))

(defun mul (a b) (if (eq b zero)
                     zero
                     (add a (mul a (cdr b)))))

;(write (add two three)) ; -> (NIL NIL NIL NIL NIL) aka six
;(write (mul four three)) ; -> (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) aka twelve
(write (mul zero three)) ; -> NIL aka zero

(defun true (a b) a)
(defun false (a b) b)
(defun my-if (a b c) (funcall a b c))

;(write (my-if #'false one two)) ; -> (NIL NIL) aka two


;(define and (lambda (p q) (if p q false)))    ; define?
;(define or  (lambda (p q) (if p true  q)))    ; define?



Multithreading waer eigentlich nicht so schwer: solange nix geschrieben werden kann, braucht eigentlich nur die
Symboltable synchronized sein ?!?
-> und das environment?
 
Methoden ConsCell toList(), toArray(), toMap(), iterator(), stream()??? map() flatMap()
-> damit bekommt man Ergebnis-Daten raus am Ende des Lisp Programms
-> Wenn man dem Interpreter eine read Funktion ins Environment mitgibt, bekommt man auch Daten rein (abgesehen vom
Lesen von stdin). So eine read Funktion koennte z.B auch XML oder JSON nach ConsCells parsen
    -> iterator ist erledigt

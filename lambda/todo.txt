        ThreadMXBean threadBean = null;
        long startCpu = 0L;
        long start = 0L;

            threadBean = ManagementFactory.getThreadMXBean();

            if (threadBean != null) {
                startCpu = threadBean.getCurrentThreadCpuTime();
            }
            start = System.nanoTime();

primitives format und format-locale: erstes bzw. zwei erste args sind strings, schreiben nach lispStdout

Variable INTERNAL-TIME-UNITS-PER-SECOND
Builtins GET-INTERNAL-REAL-TIME, GET-INTERNAL-RUN-TIME, SLEEP



continuations: loops gibts ja keine, ist eine continuation einfach der restliche parse tree? 
ist currentcc cdr(exp) (und das env bzw. closure) ?

bei endcalls koennte man die parameter der aktuellen funktion fuer namensgleiche parameter nutzen: 
nicht alle argumente dranhaengen, sondern entweder dranhaengen oder bei gleichnamigen den alten wert ersetzen
wuerd ggf bei dynamic UND lexical closures was bringen
-> nein nur dynamic, lexical closures erben das environment ja nicht

defun einbauen, weil define alleine ist muehsam
oder doch defun als macro und macros unterstuetzen?
(defmacro defun (sym params body) (define sym (lambda params body)))

lexical closures muessten gehen, indem man das env mit dem lambda mitspeichert und beim aufruf des lambda 
nicht das aktuelle env extended sondern das abgespeicherte
-> umsetzen, indem "lambda" nicht ein lambda ins environment steckt sondern "closure" 
   (oder doch ein lambda und die liste enthaelt nicht nur ("lambda" args body) 
   sondern ("lambda" args body closure), mit nullcheck entscheiden, 
   ob lambda oder closure ausgefuehrt wird. und eval() erweitern, dass closure wie lambda verarbeitet wird, 
   aber statt aktuellem env die closure mit args erweitert
-> mit befehlszeilen parameter --dyn umstellen

eval ins environment einhaengen?

interpreter bekommt eine methode init()
interpret() überladen das kein neuer parser uebergeben wird. damit kann man immer wieder interpret() aufrufen und defines bleiben bestehen

alles geparste in main merken, und mit :w in eine datei schreiben
weitere debug gschichten wie zb :env fuer environment auflisten





der Parser koennte integer auch parsen, ggf. auch char, long, biginteger, bigdecimal mit irgendeinem praefix gekennzeichnet. 
sind alle Number, k.a. ob das beim erweitern der operatoren was bringt
-> dann bräuchte man wohl auch typumwandelfunctionen, sonst stellts string-format auf, wenn man nicht mehr weiss was man hat



read koennte einen optionalen ersten string parameter als filename interpretieren und dieses file lesen
statt lispStdin

cadr, caddr, cadar, cddr, ... in eval verwenden und schauen, wieviel kleiner eval wird
-> solche primitiven wuerden auch Lisp programme schneller machen weil weniger assoc aufrufe
-> ein optimizer, der in define oder lambda reingezwickt wird, koennte (car (cdr o)) erkennen und durch (cadr o) ersetzen
   mit rekursivem abstieg muesste man nur current node und naechste stufe betrachten
   car/car  -> caar
   car/caar -> caaar
   car/cadr -> caadr
   car/cdr  -> cadr
   car/cdar -> cadar
   car/cddr -> caddr

   cdr/car  -> cdar
   cdr/caar -> cdaar
   cdr/cadr -> cdadr
   cdr/cdr  -> cddr
   cdr/cdar -> cddar
   cdr/cddr -> cdddr

buitlin apply-java: erster parameter ist ein string statt symbol, d.h. die expression fuer das erste argument muss einen String liefern,
das ist dann der Name einer Klasse und/ oder statischen Methode. Ggf. auch eine statische Methode,
die ein Function<ConsCell,Object> Javalambda liefert.

beispiel, wie man einen logger einhaengen kann.

LambdaJ ist fast ein Subset von CL, Unterschiede zu CL dokumentieren, am besten ein kurzes Manual mit allen Sprachmitteln
und ggf. Unterschieden
oder ein builtin "help": (help) listet alle special forms und builtins nach lispStdout, (help symbol) schreib eine Beschreibung
zu "symbol" nach stdout

LambdaJError extends RuntimeException   ... abstract
Syntaxerror extends LambdaJError        ... nur eval
RuntimeError extends LambdaJError       ... nur primitives

Vielleicht doch set/setq, define/defun vgl ABOUT LISP https://graham.main.nc.us/~bhammel/graham/lisp.html
rplaca, rplacd
Vielleicht ein "Imperative Paket" mit flags ein/ausschalten?

        if(car(exp) == s_define)                        // "define"
          return(extend_top(car(cdr(exp)),
                            eval(car(cdr(cdr(exp))), env)));
        if(car(exp) == s_setb) {                        // "set!"
          obj *pair   = assoc(car(cdr(exp)), env);
          obj *newval = eval(car(cdr(cdr(exp))), env);
          setcdr(pair, newval);
          return newval;
        }



ConsCell hat 4 byte platz wg alignment. man koennte ein int mit typ machen statt LambdaJString und instanceof.
CONS=0 PRIM = 1 LAMBDA=2 CLOSURE=3 ATOM=10 SYMBOL=10 STRING=11 CHAR=12 DOUBLE=12
isAtom() { return typ >= ATOM }, dann koennte custom code seine eigenen typen erfinden.
solange die neuen typnummern >= ATOM sind, sieht der interpreter alles als atom
-> geht doch nicht so: das flag wird nicht bei ConsCell gebraucht, sondern bei den values, die als Object car oder cdr gespeichert sind

k.a. wieviel die ConsCell casts bremsen
Alternatives Objectmodell mit weniger casts:

interface Value {
    default car() { throw new Error("not a cons"); }
    default cdr() { throw new Error("not a cons"); }
    String toString();
}

interface Atom extends Value {
    Object value;
    String toString() { return value.toString(); }
}

class ConsCell extends Value {
    Value car, cdr;
}

Value car(Value v) { return v.car(); }
Value cdr(Value v) { return v.cdr(); }
ConsCell cons(Value car, Value cdr) { return new ConsCell(car, cdr); }



redefinieren der symbole von special forms verbieten? auswirkung hats eh keine.

nice to have: apply mit zuviel/ zuwenig args fuer ein lambda: ueberschuessige args koennten gemeinsam mit dem letzten als liste uebergeben werden,
fehlende als null.


Doku: ein Custom Parser koennte statt parsen eine Liste liefern (koennte z.B. hardcodiert
mit new ConsCell zusammengestoppelt werden) und intern() koennte mittels String.intern() umgesetzt werden.
Anmerkung: Symbols sind Strings, Stringliterale in der o.a. Liste sind bereits mit String.intern() bearbeitet,
  dazu passt die Umsetzung der Parsermethode intern() mittels String.intern()
Anmerkung 2: Lisp Strings werden als LambdaJString repraesentiert
Anmerkung 3: intern() mit einer HashMap waer auch nicht schwer

Doku: https://en.wikipedia.org/wiki/Peano_axioms enthaelt natuerliche Zahlen basierend auf Mengen,
koennte eine Anleitung sein, wie man Zahlen in einem Lisp ohne Zahlen umsetzen kann
0 = nil
1 = succ(0) = '(0) = '(nil)
2 = succ(1) = '(0 1) = '(nil (nil))
3 = succ(2) = '(0 1 2) = '(nil (nil (nil)))

addition:
(add (a b) (if (null? b) a (add '(nil a) (cdr b))) ; oder so aehnlich

multiplikation:
(mul (a b) (if (null? b) nil (add a (mul a (cdr b)))) ; oder so aehnlich


Clisp:
(setf zero ())                                ; -> zero = NIL

;(define (cons a b) (lambda (f) (f a b)))      ; define?
;(define (car c) (c (lambda (a b) a)))         ; define?
;(define (cdr c) (c (lambda (a b) b)))         ; define?
    
(defun succ (a) (cons zero a))                ; das geht

(setf one (succ zero))                        ; -> one = (NIL)
(setf two (succ (succ zero)))                 ; -> two = (NIL NIL)
(setf three (succ (succ (succ zero))))        ; -> three = (NIL NIL NIL)
(setf four (succ (succ (succ (succ zero)))))  ; -> four = (NIL NIL NIL NIL)

(defun add (a b) (if (eq b zero)
                     a
                     (add (succ a) (cdr b))))

(defun mul (a b) (if (eq b zero)
                     zero
                     (add a (mul a (cdr b)))))

;(write (add two three)) ; -> (NIL NIL NIL NIL NIL) aka six
;(write (mul four three)) ; -> (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) aka twelve
(write (mul zero three)) ; -> NIL aka zero

(defun true (a b) a)
(defun false (a b) b)
(defun my-if (a b c) (funcall a b c))

;(write (my-if #'false one two)) ; -> (NIL NIL) aka two


;(define and (lambda (p q) (if p q false)))    ; define?
;(define or  (lambda (p q) (if p true  q)))    ; define?



-> "intern" wird bremsen, koennte HashMap oder selber geschnitzte Open Hashing Map sein
   zumindest die Symbole wie lambda, labels,... nicht immer wieder internen, sondern deferred supplier
   -> symbole memoizen ist erledigt
-> der Lookup in env wird bremsen (jmh sagt: assoc braucht 40%), auf HashMap String->ArrayList umstellen ist nicht so trivial, weil
das Environment bei funcall staendig erweitert/ zurueckgesetzt wird (fuer funcall wird das environment erweitert,
dann gehts mit dem urspruenglichen weiter). Vielleicht eine Art Kette von Maps? funcall erzeugt eine neue Map die
einen link zum vorgaenger hat 

Zweiter Versuch:
Das Environment sieht nur der Java Code, duplikate sind verboten. HashMap muesste also doch gehen?!
Zugriff nur mit assoc und extend, extend schmeisst eine Excpeption, falls es das symbol schon gibt.
sogar set! muesste gehen?!
-> nein, geht auch nicht. beim aufruf von funktionen gibts schon duplikate, und nach dem return der funktion
   muss das environment wieder abgeraeumt werden, s.o.





Multithreading waer eigentlich nicht so schwer: solange nix geschrieben werden kann, braucht eigentlich nur die
Symboltable synchronized sein ?!?
 
Methoden ConsCell toList(), toArray(), toMap(), iterator(), stream()??? map() flatMap()
-> damit bekommt man Ergebnis-Daten raus am Ende des Lisp Programms
-> Wenn man dem Interpreter eine read Funktion ins Environment mitgibt, bekommt man auch Daten rein (abgesehen vom
Lesen von stdin). So eine read Funktion koennte z.B auch XML oder JSON nach ConsCells parsen
    -> iterator ist erledigt



(char-int C:character): integer expr ; Converts character to integer.
(int-char I:integer): character expr ; Converts integer to character.

The read syntax for characters objects is simple: #\ followed by the desired character. 





http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node149.html
list-length could be implemented as follows:

(defun list-length (x) 
  (do ((n 0 (+ n 2))            ;Counter 
       (fast x (cddr fast))     ;Fast pointer: leaps by 2 
       (slow x (cdr slow)))     ;Slow pointer: leaps by 1 
      (nil) 
    ;; If fast pointer hits the end, return the count. 
    (when (endp fast) (return n)) 
    (when (endp (cdr fast)) (return (+ n 1))) 
    ;; If fast pointer eventually equals slow pointer, 
    ;;  then we must be stuck in a circular list. 
    ;; (A deeper property is the converse: if we are 
    ;;  stuck in a circular list, then eventually the 
    ;;  fast pointer will equal the slow pointer. 
    ;;  That fact justifies this implementation.) 
    (when (and (eq fast slow) (> n 0)) (return nil))))



isNaN, isInfinite, isFinite
-> ggf. parameter "Error bei NaN, Infinity etc."
div, remain, trunc, round, abs
weitere operatoren aus java.lang.Math (oder StrictMath?)

irgendwie fliessen eval und apply ineinander. apply kann man mit eval implementieren, und umgekehrt?!



Vielleicht car, cdr, cons, ConsCell in eine Basisklasse LambdaJRuntime rausziehen?
LambdaJ koennte man als Lisp Programm sehen, das von Hand nach Java uebersetzt wurde,
und ein Lisp Programm verwendet Lisp Runtime wie car, cdr, ... .
Falls ein LambaJ Compiler kommt, wuerden erzeugte Java Programme dieselbe Runtime verwenden.
Fuer interpretierte Programme gibts die Builtin-Wrapper, die Parameter-Checks machen und
die Argument-Liste in Argumente wandeln.
-> public static nested class LambdaJRuntime + "import static LambdaJ.*"
   damit gaebs nur wenig Aenderungen in LambdaJ, und externer Code haette auch Zugriff mittels "import static LambdaJ.*" 

Falls Compiler, sollte der nicht nur ein Programm sondern z.B. *.lisp uebersetzen,
ggf. mit timestampcheck



(loop for thing in list
   do (if (numberp thing)
          (format nil “I’m a number: ~a~%” thing)
          (format nil “Not a number!~%”)

(defun factorial(x)
  (reduce '* (loop for a from x downto 1 collect a)))



(write (((lambda () (lambda () (quote (1 2 3))))))) ; geht nur in scheme siehe apply.lisp





flag ob die identifier auf UC umgestellt werden sollen



try/ catch für javacode in eval statt in d, weil da kann man in der Fehlermeldung die Expression ausgeben

JDBC vielleicht objectorientiert anbinden?
funktion nativequery bekommt eine datasource, einen SQL string und eine Liste mit (parameternameatom . wertexpression) tupeln

nativeinsert koennte fuer batchinserts eine Liste von listen mit (parameternameatom . wertexpression) tupeln bekommen und eine liste 
mit ints liefern (ein int für jede insert-tupel-liste)

lexikalische closures





Doch (noch) nicht:
==========================================

builder pattern:
withStdin(...)        // entweder einen char supplier oder einen ObjectReader
withStdout(...)       // entweder einen String consumer oder einen ObjectWriter
withCustomEnv(...)    // Parameter ist ein Supplier<ConsCell>, der erzeugt eine Liste mit (symbol . builtin)
                      // und wird in der Init Phase aufgerufen
withTrace(Tracer)     // z.B. System.err::println
withTty()             // Shortcut/ convenience: benutzt System in/out/err, kein Custom Env
obige methoden liefern ein Interface "LambdaJBuilder" OHNE interpret aber mit build()
build()               // bastelt alles zusammen und liefert ein Interface "LambdaJ" mit interpret(), withStdin(), withStdout()
interpret(...)        // entweder einen char supplier oder einen Parser, oder ein String?!

eine map builtinfunc->name damit printObj die funktionsnamen ausgeben kann?
zweite map fuer FFI funktionen s.u.?

Wenn ConsCell geeignet annotiert ist, sollte jaxb dann XML nach Lists parsen koennen? XML schreiben muesste supereinfach sein?!
-> es braucht viele annotations und public noarg constructors, zawos brauchma des

lisp write liefert als ergebnis den parameter
-> LambdaJ liefert (quote t)





Erledigt:
==========================================

welches ergebnis liefert lambda mit einer liste als body?
-> sollte ergebnis der letzten form sein

Klasse Builtin statt UnaryOperator<Pair> einfuehren

eq vergleicht identitaet, was macht Lisp? https://stackoverflow.com/questions/547436/whats-the-difference-between-eq-eql-equal-and-equalp-in-common-lisp
-> checken ob das passt, z.b. (eq (cons (quote 1) (quote 2)) (cons (quote 1) (quote 2))) ist nicht identisch aber gleich (?)
-> GNU CLISP v2.49+ liefert NIL

Eine JUnit funktion, die liest alle lisp files aus einem verzeichnis und führt sie aus.
erwartetes Ergebnis bzw. fehlermeldung steht in der datei in einem kommentar drin, z.B.
; result:(1 . 2)
oder
; error-prefix: SyntaxError in line 12:
und ggf.
; output: Hallo Welt

Lambda -> LambdaJ

Vielleicht in printObj umlenken:
(quote t) -> "t"
null -> "nil"

beim scannen zeile und spalte mitzaehlen und in fehlermeldung einbauen

apply fuer lambdas, siehe apply.lisp

verschiedene konstruktoren fuer Pair und ueberladene cons brauchts wahrscheinlich nicht, cons(Object,Object) muesste reichen

builtin write-line
-> common lisp hat das, parameter muss aber ein string sein

Datentyp double, (nicht int) unterstuetzen

eq fuer number korrigieren
-> oder eq lassen und = einfuehren, achtung beim vergleichen von double!
-> vielleicht = mit optionalem drittem double parameter fuzz fuer die genauigkeit

+ - * / %, factorial beispiel

car, cdr umstellen dass sie Object uebernehmen
-> dann gibts einen cast in car/cdr statt 1000 casts ueberall

vielleicht "Object car(Object)" und "Pair pcar(Object)"?
-> Eruebrigt sich ggf. durch Umstellen von car(Pair) nach car(Object) 

die parameterchecks ignorieren zuviele argumente

numberp, ggf. atom korrigieren
symbol? vs atom vs numberp

<, >, usw checken ob Double#compareTo Vorteile bzgl. NaN und +- 0.0 hat, derzeit passiert Unboxing

tests fuer atom, consp, listp, symbolp, numberp

test fuer eval nil und eval t, ggf. symbol t einfuehren

tests und fehlertests fuer number und operatoren

numberp() ggf. teilweise durch atom() ersetzen, dann koennen externe Builtins ihre eigenen Datentypen
in car reinstecken, der Interpreter sieht und verarbeitet nur Object

errortests fuer lambda/ builtin mit zuviel/ zuwenig parametern aufrufen

errortests fuer fehler wie erster parameter fuer lambda ist keine symbolliste

Sollen die interpret...() Methoden einen String oder ein Objekt zurueckgeben?
Vielleicht Object zurueck, und ConsCell bekommt eine toString() Methode basierend auf printObj?

Scanner/Parser in eine Klasse rausziehen, je ein Objekt ProgramParser und InputDataParser,
die Lisp Funktion read verwendet den InputDataParser.
Symboltabelle zu geeigneten Zeitpunkten auf null setzen, wahrscheinlich im Konstruktor der ScannerParserKlasse

if(!strcmp(token, "\'")) return cons(quote, cons(readobj(), nil));

isParen und isQuote nach isSyntax zusammenziehen



Tail recursion erkennen: es wird eine Funktion aufgerufen, die im environment 1 hoeher ist (?)
oder wenigstens loop einbauen
-> einfacher ists alle tailcalls zu optimieren

eval hat einige endrekursive aufrufe. koennte man eliminieren.
vielleicht noch einen zweiten levelzaehler einfuehren, dann kann man den level fuer eval und (kleinere) rekursionstiefe anzeigen

eigentlich passiert die rekursion ja in eval:
evlis, evcon & co inline expandieren, und das letzte listenelement nicht mit rekursion aufrufen sondern
manuell tail recursion elimination machen.

PROBLEM: function calls haben ein geaendertes environment extenv
-> einen stack aus extenvs aufbauen: ein int "stackarray" in dem merkt man sich, wieviele elemente vorne
drangepickt wurden und nach verarbeiten des calls entfernt werden müssen 

dann werden nicht nur tail rekursionen wegoptimiert, sondern alle tail calls. es ruft zwar die eine Lisp funktion
eine andere auf, aber in wirklichkeit laeuft nur der code der einzigen Java-methode eval. 



eval, evlis, evcon vielleicht in haendischem CPS?!?
-> eruebrigt sich durch TCO

Erkennung von zirkulaeren Listen koennte man in printObj einbauen
-> aber ohne set gibts derzeit eh keine zirkulaeren Listen ?!?)
-> contains self aber schon

printObj auf loop umbauen, "sich selbst enthalten erkennen", vgl collection.toString()

"t" aus/ einschaltbar machen: flag "HAVE_TRUE"
-> falls true  -> t in der symbol table und _expTrue = t
-> falls false -> t nicht in der symbol table und _expTrue = (quote t)

Numbersupport mit flags ausschalten?
Optional BigDecimal statt Double?

fnull, fcons usw brauchen keine members zu sein, koennten lokale variablen in environment() sein
-> vorher environment() aufteilen?

der Double Support ist eigentlich nur mittels Builtins umgesetzt
-> in ein eigenes ExtEnv verpacken, damit kann mans optional machen,
   oder alternativ/ zusaetzlich z.B. BigDecimal unterstuetzen
-> UND im Lexer gibts Support fuer Double

--help

Datentyp Strings unterstuetzen
-> laenger als SYMBOL_MAX=32

Strings und Characters braucht eigentlich nur der Scanner, Parser (readObj) und Builtin Funktionen (inkl printObj!!!) kennen.
Strings, Chars und Symbols sind alles Atoms, aber nur Symbols sind in der Symboltable

Parser refactoren:
LispParser bekommt statt InputStream einen IntProducer:
fuer InputStream in:
    () -> in::read
oder fuer StringReader s:
    () ->  s::read

readObj umbauen dass (a . b) eingelesen werden kann?

Builtins sollten ggf. expression mitbekommen fuer ausgabe von fehlermeldungen

printObj sollte symbols mit syntax als |xxx| printen. Was syntax characters sind, weiss nur der Parser
-> printObj als Methode von Parser, naechsten punkt umsetzen!

Builtins sollten ggf. parser (symboltabelle) und ggf. environment mitbekommen, dann koennten sie static sein,
waer ggf. besser fuer custom builtins
-> builtins mit env koennten late binding machen
-> builtins muessen printObj des parsers verwenden
-> environment() koennte static sein

!!!!!!! Alles falsch: Syntax characters bestimmt der ObjectWriter.
Builtins sollten Symboltabelle, ObjectReader in, ObjectWriter out, ggf. Tracer, ggf. Environment bekommen

write sollte ObjectWriter.printObj() verwenden,
zum Tracen weiterhin das statische printObj verwenden
-> LispParser (eigentlich ObjectWriter, s.u.) bekommt methode printObj, bisherige statische Methode printObj in traceObj umbenennen oder printSExpression 
-> write schreibt im gewuenschten Format, Errormessages sind im Format S-expression
-> Syntax characters von S-expressions als static Konstante von LambdaJ rausziehen,
   dann kanns Lispparser und das statische printObj verwenden



getrennter Reader fuer read
-> Object interpret(Supplier lispSource, Supplier lispStdin, Consumer lispStdout, Supplier<ConsCell> customEnvironment)
-> oder LambdaJ in Builder Pattern umbauen:

interface ObjectReader { Object readObj(); }
interface SymbolTable { String intern(); }
interface Parser extends ObjectReader, SymbolTable

interface ObjectWriter { String printObj(Object o, boolean headOfList, boolean eol); }
class LispParser implements Parser, ObjectWriter

interface Tracer { void println(String); }

FFI: eine special form "extlabels". funktioniert aehnlich wie labels,
aber statt funktionsdefinitionen gibt man einen Klassennamen an (und vielleicht ein zusaetzliches optionales namenspraefix,
damit man im falle von gleichnamige methoden in zwei klassen "namespaces" zum trennen verwenden kann), und
von dieser klasse werden alle public methoden mit der Signatur UnaryOperator<Pair> ins Environment gesteckt.
Oder statt reflection: "extlabels" bekommt den Namen einer statischen methode die liefert eine Map Funktionsname->UnaryOperator<Pair>

Oder: LambdaJ bekommt eine Methode void registerBuiltin(String funcName, Builtin javaFunc), die pickt eine neue
Funktion ans Environment vorne dran.
Oder: zus. Parameter ConsCell extEnv, damit kann man eine Liste mit zusaetzlichen Builtins mitgeben



primitive string-format-localized: erster parameter ist locale, z.B.
(format-string-localized "en-US" "%g" 1)

evlis/ evcond sollten auch was tracen. stackanzeige erhoehen, evallevel nicht
einrueckung basiert auf javastackzaehler, anzahl sterndaln evallevel - javastackzaehler

apply erlaubt nur 2 argumente, sollte aber 2+ akzeptieren (und gegen parameterliste checken?)
siehe apply3.lisp
laut http://www.n-a-n-o.com/lisp/cmucl-tutorials/LISP-tutorial-20.html:
(apply #'+ 3 4 '(3 4))
Apply is just like funcall, except that its final argument should be a list; the elements of that list are treated
as if they were additional arguments to a funcall.
-> apply ist komplett hinueber

(write " ") schreibt " " inkusive der double quotes
-> vielleicht write-string und write-line

Escapig von " ", ', \ ...
SExpWriter sollte so schreiben wie SExpReader liest, d.h. mit escaping
ConsCell.toString() sollte nicht escapen
todo gelesen wird ein Symbol he\(lo, geschrieben wird |he(lo|

Wenn eine Funktion labels oder cond enthaelt, werden tailcalls effektiv nicht wegoptimiert, weil evlabels bzw. evcond
auf den Java stack kommt. "if" ist in eval inline drin, deswegen funktioniert TCO trotz "if".

environment umsortieren

eval braucht keine elsif Kette sein: in jedem if gibts return oder continue

applyPrimitive (2x) in eval in ein try/catch wrappen, im catch:
throw new LambdaJError(e.getMessage + expError(exp))
-> damit sieht man in welcher expression z.B. argumente nicht passen

evlabels inlinen und TCO

performance: benchmarken
warum ist das environment eine liste von listen statt eine liste von cons cells

am ende wird stack und nesting getraced falls TRC_EVAL.
-> TRC_STATS statt TRC_EVAL, zusaetzlich walltime, cpu und anzahl ConsCells tracen.

in dbeval die groesse des environment ausgeben. wahrscheinlich waechst das bei rekursion. 

statt dbgEval -> if (trace >= TRC_EVAL) dbgEval
und die if clause aus dbgEval weg

ggf mit :init altes environment vergessen

im main loop: parsen und checken, ob obj.toString = :w oder = :q ist, so koennte man befehle für den REPL ausserhalb Lisp einbauen

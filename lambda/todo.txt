Tail recursion erkennen: es wird eine Funktion aufgerufen, die im environment 1 höher ist (?)
oder wenigstens loop einbauen

eval hat einige endrekursive aufrufe. könnte man eliminieren.
vielleicht noch einen zweiten levelzähler einführen, dann kann man den level für eval und (kleinere) rekursionstiefe anzeigen

eigentlich passiert die rekursion ja in eval:
evlis, evcon & co inline expandieren, und das letzte listenelement nicht mit rekursion aufrufen sondern
manuell tail recursion elimination machen.

PROBLEM: rekursive calls haben ein geändertes environment extenv

dann werden nicht nur tail rekursionen wegoptimiert, sondern alle tail calls. es ruft zwar die eine Lisp funktion
eine andere auf, aber in wirklichkeit läuft nur der code der einzigen Java-methode eval. 





verschiedene konstruktoren für Pair und überladene cons brauchts wahrscheinlich nicht, cons(Object,Object) müsste reichen

beim scannen zeile und spalte mitzählen und in fehlermeldung einbauen

printObj auf loop umbauen, zirklen erkennen, vgl collection.toString()

LambdaJError extends RuntimeException
Syntaxerror extends LambdaJError
RuntimeError extends LambdaJError
ExtFuncError extends RuntimeError



readObj umbauen dass (a . b) eingelesen werden kann?

flag ob die identifier auf UC umgestellt werden sollen

builtin write-line
-> common lisp hat das, parameter muss aber ein string sein

lisp write liefert als ergebnis den parameter
-> ich liefere (quote t)

Vielleicht in printObj umlenken:
(quote t) -> "t"
null -> "nil"

eine map builtinfunc->name damit printObj die funktionsnamen ausgeben kann?
zweite map für FFI funktionen s.u.?

eval ins environment einhängen?

Datentypen Strings, double, int unterstützen

Klasse Atom extends String, Function extends String. car ist dann entweder UnaryOperator oder Atom oder Function.
Das wär für Integer und Double erweiterbar.

FFI: eine special form "extlabels". funktioniert ähnlich wie labels,
aber statt funktionsdefinitionen gibt man einen Klassennamen an (und vielleicht ein zusätzliches optionales namenspräfix,
damit man im falle von gleichnamige methoden in zwei klassen "namespaces" zum trennen verwenden kann), und
von dieser klasse werden alle public methoden mit der Signatur UnaryOperator<Pair> ins Environment gesteckt.
Oder statt reflection: "extlabels" bekommt den Namen einer statischen methode die liefert eine Map Funktionsname->UnaryOperator<Pair>

try/ catch für javacode in eval statt in d, weil da kann man in der Fehlermeldung die Expression ausgeben

lexikalische closures

JDBC vielleicht objectorientiert anbinden?
funktion nativequery bekommt eine datasource, einen SQL string und eine Liste mit (parameternameatom . wertexpression) tupeln

nativeinsert könnte für batchinserts eine Liste von listen mit (parameternameatom . wertexpression) tupeln bekommen und eine liste 
mit ints liefern (ein int für jede insert-tupel-liste)



Erledigt:

welches ergebnis liefert lambda mit einer liste als body?
-> sollte ergebnis der letzten form sein

Klasse Builtin statt UnaryOperator<Pair> einführen

eq vergleicht identität, was macht Lisp? https://stackoverflow.com/questions/547436/whats-the-difference-between-eq-eql-equal-and-equalp-in-common-lisp
-> checken ob das passt, z.b. (eq (cons (quote 1) (quote 2)) (cons (quote 1) (quote 2))) ist nicht identisch aber gleich (?)
-> GNU CLISP v2.49+ liefert NIL

Eine JUnit funktion, die liest alle lisp files aus einem verzeichnis und führt sie aus.
erwartetes Ergebnis bzw. fehlermeldung steht in der datei in einem kommentar drin, z.B.
; result:(1 . 2)
oder
; error-prefix: SyntaxError in line 12:
und ggf.
; output: Hallo Welt

Lambda -> LambdaJ

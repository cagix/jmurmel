ggf. ein subset von lisp printer umsetzen http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_writecm_p_rintcm_princ.html
prin1 object &optional output-stream => object

prin1 produces output suitable for input to read.
princ is just like prin1 except that the output has no escape characters.
print is just like prin1 except that the printed representation of object is preceded by a newline and followed by a space.
pprint is just like print except that the trailing space is omitted and object is printed with the *print-pretty* flag non-nil to produce pretty output.

lisp eol von cmdline parameter auf lisp global umstellen
-> oder write uebernimmt liste mit keyword/value tupel: (write obj flags...), z.B.
   (write "Hallo" (list ('eol-style 'lisp) ('escape-atoms t) ('max-length 20) ('pprint t)))
-> oder write uebernimmt *optionale* liste, fallback ist eine globale variable *print-environment* mit soner liste
   (write "Hallo") ; write benutzt *print-environment*
   (write "Hallo" (cons ('(max-length 20) *print-environment*))) ; write benutzt argument


funktion fatal dokumentieren, ggf. umbenamsen

https://people.eecs.berkeley.edu/~bh/ssch27/appendix-cl.html
beschreibt unterschiede zw. scheme und CL und ist damit ein guter ueberblick ueber CL, auch file open/ close

ANSI-CL hat die beiden funktionen lisp-implementation-type, lisp-implementation-version
-> https://franz.com/support/documentation/9.0/ansicl/dictentr/lisp-imp.htm

cl hat with-open-file


CDI und EJB aehnlich :: integrieren?
-> dazu brauchts eigentlich einen Lookup im Java-Scope, d.h. BeanProvider.getContextualReference() muss i-wie integriert werden
   -> DeltaSpike so verpacken, dass i-wie ein CustomEnvironmentSupplier uebrigbleibt
   -> kann man das aufrufen eines CustomEnvironmentSupplier in eine Murmel Funktion verpacken?

cmdlineflags wos let aber nicht letXXX oder ggf named let gibt
-> --no-scheme, auch null? und ggf if abdrehen
-> dann gibts nur mehr not bound, kein undefined value

:: macht im prinzip dasselbe wie CL create-method
-> ggf parameterreihenfolge anpassen
   hinweis in murmel-langref.lisp

zus Primitives: https://learnxinyminutes.com/docs/common-lisp/
(expt x y) -> x hoch y, wurzelziehen? oder ist das (x hoch 1/y)?
(intern string) -> symbol
-> intern ist case preserving (intern "aaa") -> |aaa|, anscheinend macht der reader uppercase, und symbol lookup ist case sensitive
AND, OR, XOR, NOT
-> brauchts eigentlich nicht, ist sugar ueber if
null? brauchts eigentlich nur in scheme, (null? x) -> (not x)
-> umbenamsen


Datei IO
(pprint (read (open typ "/Users/ashokkhanna/lisp/test-pprint.lisp"))) ; typ koennte 'utf-8 oder 'ansi oder auch 'url oder 'ftp sein
-> datentyp File
-> funktion (open string...) -> File ; koennte eine menge pathelemente bekommen, setzt die mittels pathsep zusammen vgl NIO
            (close file) -> t
            (read-line file) -> String oder nil
            (read-all-lines file) -> (line...)
bringt aber nur was, wenns auch stringmanipulationsfunktionen gibt
-> string->charlist
-> (split splitchars sting) -> (elements...)

(load 'utf-8 "lispfile.lisp")
-> erster optionale parameter ist ein symbol fuer den Zeichensatz

Stringfunktionen: format kann auch strings zusammensetzen
strings sind eine LSIP sequence, fuer sequence gibts
-> subseq sequence start &optional end => subsequence

(concatenate 'string "all" " " "together" " " "now") =>  "all together now"
(concatenate 'list "ABC" '(d e f) #(1 2 3) #*1011)
=>  (#\A #\B #\C D E F 1 2 3 1 0 1 1)
(concatenate 'list) =>  NIL

CL hat stringp string= string<=, ...

read koennte einen optionalen ersten string parameter als filename interpretieren und dieses file lesen
statt lispStdin, write sinngemaess, ggf. format und format-locale

primitives fuer Environmentvariables und -D Java Systemproperties. wenns nicht existiert, gibts nil, wenns nicht als
double lesbar ist, gibts NaN
primitives fuer isNan, oder konstanten NaN, Infinity und (eq d NaN)


JDBC vielleicht objectorientiert anbinden?
funktion nativequery bekommt eine datasource, einen SQL string und eine Liste mit (parameternameatom . wertexpression) tupeln

nativeinsert koennte fuer batchinserts eine Liste von listen mit (parameternameatom . wertexpression) tupeln bekommen und eine liste 
mit ints liefern (ein int fÃ¼r jede insert-tupel-liste)


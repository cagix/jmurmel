flag ob die identifier auf UC umgestellt werden sollen

builtin write-line
-> common lisp hat das

eq vergleicht identität, was macht Lisp? https://stackoverflow.com/questions/547436/whats-the-difference-between-eq-eql-equal-and-equalp-in-common-lisp
-> checken ob das passt, z.b. (eq (cons (quote 1) (quote 2)) (cons (quote 1) (quote 2))) ist nicht identisch aber gleich (?)
-> GNU CLISP v2.49+ liefert NIL

lisp write liefert als ergebnis den parameter
-> ich liefere (quote t)

Vielleicht in printObj umlenken:
(quote t) -> "t"
null -> "nil"

beim scannen zeile und spalte mitzählen und in fehlermeldung einbauen

Eine JUnit funktion, die liest alle lisp files aus einem verzeichnis und führt sie aus.
erwartetes Ergebnis bzw. fehlermeldung steht in der datei in einem kommentar drin, z.B.
; result:(1 . 2)
oder
; error-prefix: SyntaxError in line 12:
und ggf.
; output: Hallo Welt

eine map builtinfunc->name damit printObj die funktionsnamen ausgeben kann?
zweite map für FFI funktionen s.u.?
eval ins environment einhängen?

printObj auf loop umbauen, zirklen erkennen, vgl collection.toString()

Klasse Atom extends String, Function extends String. car ist dann entweder UnaryOperator oder Atom oder Function.
Das wär für Integer und Double erweiterbar.
Klasse Builtin statt UnaryOperator<Pair> einführen

FFI: eine special form "extlabels". funktioniert ähnlich wie labels,
aber statt funktionsdefinitionen gibt man einen Klassennamen an (und vielleicht ein zusätzliches optionales namenspräfix,
damit man im falle von gleichnamige methoden in zwei klassen "namespaces" zum trennen verwenden kann), und
von dieser klasse werden alle public methoden mit der Signatur UnaryOperator<Pair> ins Environment gesteckt.
Oder statt reflection: "extlabels" bekommt den Namen einer statischen methode die liefert eine Map Funktionsname->UnaryOperator<Pair>


try/ catch für javacode in eval statt in d, weil da kann man in der Fehlermeldung die Expression ausgeben

LambdaJError extends RuntimeException
Syntaxerror extends LambdaJError
RuntimeError extends LambdaJError
ExtFuncError extends RuntimeError

Endrekusion erkennen: es wird eine Funktion aufgerufen, die im environment 1 höher ist (?)

JDBC vielleicht objectorientiert anbinden?
funktion nativequery bekommt eine datasource, einen SQL string und eine Liste mit (parameternameatom . wertexpression) tupeln

nativeinsert könnte für batchinserts eine Liste von listen mit (parameternameatom . wertexpression) tupeln bekommen und eine liste 
mit ints liefern (ein int für jede insert-tupel-liste)



Erledigt:

welches ergebnis liefert lambda mit einer liste als body?
-> sollte ergebnis der letzten form sein


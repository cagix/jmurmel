global symbol names muessen unique sein, lokale (noch) nicht -> dokumentieren
lambda parameternamen auch nicht, koennte ein problem sein

dynamic dokumentieren

statt reserved=cons(symbol, reserved)
-> reserved(Symbol)


Unterscheiden: Symbol gibts nicht vs. hat keinen Wert zugewiesen: not bound vs. undefined
-> spielt eigentlich bisher nur bei letrec eine Rolle

dzt gibts let* und letrec
-> let dazu, damit in den binding forms das umschliessende environment inkl globals garantiert sichtbar ist
   braucht man zum macros programmieren
-> was ist letrec*

soll bei named letXX das let-symbol in den bindings sichtbar sein?
-> CL hat kein named let
   scheme hat nur named let, kein named let* letrec, body symbol ist in den binding expressions unbound
    -> rausfinden was die nachteile von named let* und letrec sind
    -> rausfinden was die nachteile von named binding in binding expressions sind 


https://docs.racket-lang.org/reference/let.html
https://groups.csail.mit.edu/mac/ftpdir/scheme-7.4/doc-html/scheme_3.html#SEC31

LET: Lisp, Scheme, Racket   Murmel hats nicht
(let ((symbol form)...) bodyform...) -> object
* form sieht nur umschliessendes environment
* bodyform sieht umschliessendes environment und symbols

(let ((s1 form1) (s2 form2) (s3 form3)) bodyform) -> object
->
((lambda (s1 s2 s3) bodyform)
  (eval form1)
  (eval form2)
  (eval form3))


NAMED LET: Scheme, Racket      Murmel hats nicht
(let bodysymbol ((symbol form)...) (bodyform)...) -> object
* symbols muessen unique sein
* form sieht nur umschliessendes environment
* body sieht umschliessendes environment, symbols und bodysymbol


LET*: Scheme, Racket       Murmel hats korrekt und zus NAMED LET*
(let* ((symbol form)...) (bodyform)...) -> object
* the symbols need not be distinct; later bindings shadow earlier bindings.
* form sieht umschliessendes environment und vorangegangene symbols (definiert)
* body sieht umschliessendes environment und symbols

(let* ((s1 form1) (s2 form2) (s3 form3)) bodyform) -> object
->
(let ((s1 form1))
  (let ((s2 form))
    (let ((s3 form3))
       bodyform)))
->
((lambda (s1)
      ((lambda (s2)
            ((lambda (s3)
                  bodyform)
                (eval form3)))
          (eval form2)))
    (eval form1))


(letrec ((symbol form)...) (bodyform)...) -> object
* form sieht umschliessendes environment und alle symbols (undefiniert)
* body sieht umschliessendes environment und symbols

(letrec ((s1 form1) (s2 form2) (s3 form3)) bodyform) -> object
->
(let ((s1 *undefined*) (s2 *undefined*) (s3 *undefined*))
  (let ((_x_ (eval form1)) (_y_ (eval form1)) (_z_ (eval form1)))   ; unique identifiers
    (set! s1 _x_)
    (set! s2 _y_)
    (set! s3 _z_)
    bodyform))


Racket letrec == Scheme letrec*
(letrec* ((symbol form)...) (bodyform)...) -> object
* The ids must be distinct according to bound-identifier=?.
* form sieht umschliessendes environment und alle symbols (vorangegangene definiert, eigens und folgende undefiniert)
* body sieht umschliessendes environment und symbols

(letrec* ((s1 form1) (s2 form2) (s3 form3)) bodyform) -> object
->
(let ((s1 *undefined*) (s2 *undefined*) (s3 *undefined*))
  (set! s1 (eval form1))
  (set! s1 (eval form1))
  (set! s3 (eval form1))
  bodyform)


-> am besten:
   letrec weg, weil da gibts undefined (sonst nirgends), Lisp hats nicht, und man kanns durch labels ersetzen
   let und named let dazu (named let koennte man auch durch labels ersetzen aber was solls)
   let* bleibt inkl. erweiterung named let*





Fexpr unterstuetzen, in eigenen Namespace stecken und diesen Namespace nur in define auswerten/ fexpr aufrufen/ aufloesen
-> sind das dann effektiv macros?

Vielleicht in define den Lisp Code nach Java uebersetzen und mit tools.jar uebersetzen? Und aus dem erzeugten class file
ein neues primitive basteln?
-> denkbar waere ein aeusserer und ein innerer compiler. der aeussere uebersetzt nach java/c/..., der innere nach bytecode
-> vor dem compiler koennten transformationen laufen wie z.b. let->lambda, dann brauchte der compiler und eine allfaellige vm
   nicht so viele features haben
   -> oder der (bytecode) compiler erzeugt code der nur weniger vm features braucht

javax.tools.JavaCompiler comp = javax.tools.ToolProvider.getSystemJavaCompiler();
CompilationTask c = comp.getTask(null,null, null, null, null, Collcetions.singletonList(new JavaSourceFromString(..., "class...");
Boolean success = c.call();
 




das environment ist eine liste von maps:
-> zip steckt eine neu map vornedran
-> assoc arbeitet die liste ab, und durchsucht jede map, erster treffer gilt

-> ein lexikalisches environment koennte ALLE werte aller uebergeordneter environments enthalten.
   das geht, wenn kein set moeglich ist oder
   wenn die maps nur referenzen auf mutable werte enthalten: entweder mutable Java Objekte oder nicht die values
   aus dem environment sondern die (symbol . value) conses aus dem environment
   -> performance wird wohl nur dann besser, wenn solche gesamt-closures nur fuer define/ defun erstellt werden
   -> closures koennten statt map ein array bekommen, wenn alle symbolreferenzen durch arraylookups ersetzt werden
      -> in der liste mit dem code des lambda alles symbols ersetzen durch (envref n)

   -> referenzen in lexikalische closures rein aufloesen geht auch ohne maps:
      symbolreferenzen durch zugriffe auf das (symbol . value) cons ersetzen
	  vielleicht gemeinsam mit macroexpand?!?
	  -> cache fuer assoc? jedes scop beginnt mit einer neuen leeren cache-map (oder immer dieselbe, die immer wieder geleert wird),
         damit waeren mehrfache zugriffe auf das selbe symbol schneller, bei vorabaufloesen UND bei dyn env
   
define sollte das aktuelle environment erweitern, nicht das globale
zusaetzlich define-global einfuehren (ist das dasselbe wie defconst? solange keine re-definition und kein set -> ja)





AND, OR, XOR, NOT
-> brauchts eigentlich nicht, ist sugar ueber if





neuen parser: (evtl while, for (list) umsetzen?)
program ::= stmt*

stmt ::= exp ';'

exp ::= assignment | lambda | case | block | application

assignment ::= s '=' exp
-> (define s exp)

case ::= 'case' (exp block)* 'esac'
-> (cond (exp block))

block ::= '{' stmt* '}'
-> (progn explist)

lambda ::= function(p1, p2) block   		; implicit symbol 'self' for recursion
-> (lambda (p1 p2) stmt*)

application ::= builtin | f(exp1*)			; add, sub, ..., pair, list 
-> (f explist)

(e1, e2)
-> '(e1 e2)

atomexp ::= atom
-> atom


builtin:
pair(exp1, exp2)
-> (exp1 . exp2)

list(exp1, exp2, exp3)			; list(exp*)
-> (list exp1 exp2 exp3)

add(1, 2)
-> (+ 1 2)


ConsCell methoden double carAsDouble(), long carAsLong() einfuehren
-> und DoubleConsCell, LongConsCell, das hat zusaetzlich Java primitive datentypen als car und ueberlaedt die methoden

LambdaJSymbol.equals, equalsIgnoreCase aufraeumen

multivalue let: wenn funktionen mehrere werte zurueckgeben, koennte ein erweitertes letXXX zuweisen:
(let ((r1 r2 (multivaluefunction)))
   (print r1)
   (print r2))
-> gibts schon in scheme


koennte makeClosureFromForm beim closen alle (im environment vorhandenen) symbole (die spaeter ein lookup waeren)
direkt durch die (symbol . value) tupel ersetzen? support dafuer muesste anschliessend in eval eingebaut werden
-> das wuerd env cache ersparen
-> nicht einfach ersetzen, sondern ersetzen durch eine neue special form (envref (symbol . value))
   die ersetzungsroutine (die 1x laeuft) koennte einen cache haben, um mehrfache lookups auf dasselbe symbol zu vermeiden
-> closure braucht man dann nur mehr fuer den dynamischen lookup der globalen variablen dies beim closen noch nicht gab
    -> auch solche globalen referenzen koennten beim aufruf der closure beim ersten zugriff auf nunmehr existierende globals umgepatcht werden
-> nur bei define/ defun machen, ggf. noch bei labels?
-> soll envref ein reserved word sein, oder darf das bei eval und/ oder macros verwendet werden?
   -> koennte auch versteckt sein, es gibt ein Object sEnvref, aber nicht "sEnvref = intern("envref")" sondern "sEnvref = new Object()"
      -> das koennte man spaeter durch umstellen sichtbar machen, ggf. mit anderem symbolnamen
-> das muesste die schlimmsten performance probleme bei groesseren programmen erledigen ?!?

-> beim aufruf wird derzeit env/ closure mit cons erweitert. man koennte obigen trick auch auf die parameter anwenden 
   parameter gehoeren nicht zur closure (wuerden sich sonst bei rekursion ueberschreiben).
   beim aufruf koennte statt environment erweitern eine arraylist mit werten uebergeben werden:
        - die liste mit parameternamen ist bekannt, im array stehen werte an jenem index, der dem index des symbols in der parameterliste entspricht
        - index 0 ist ein uplink zur closure
        - zugriffe auf parameter muessten ersetzt werden durch (paramref idx)
        - die arraylist bekommt eval als parameter env, eval muss dynamische symbol lookups mit assoc(symbol, env[0]) machen statt assoc(symbol, env) oder assoc wird angepasst
        - beim environment extenden fuer aufrufe aus einer closure heraus brauchts auch anpassungen -> eigentlich nicht, wenn assoc erweitert wird
        - es waer einfach, slots in der arraylist fuer selbstrekursive tailcalls wieder zu verwenden
    


printSEx: if (car(list) == sQuote) print "'" + printSex(cdr(list))
der reader sollte wsl ' immer auf (quote... umsetzen, egal ob quote unterstuetzt wird oder nicht

umbenennen:
lispStdout -> lispPrinter
ObjectReader -> LispReader, #readObj -> #read
ObjectWriter -> LispPrinter, #printObj -> #print

tests von lis.py verpacken

behandlung von nil beschreiben (Lisp <> Scheme)

in readme.md nur einfache beispiele, rest in features.md

mit maven replace regex aus murmelref.lisp eine murmelref.md datei erzeugen


synchronized ueberlegen

JSR223 vielleicht in ein zweites jar verpacken?





koennt ma namespaces irgendwie so einfuehren:
namespace xxx biegt topenv woandershin
define schreibt nicht in topenv sondern ins package
export schreibt ins topenv
assoc sucht erst im aktuellen namespace, dann in topenv (wie spielt das mit den gestapelten environments zusammen?)
-> namespaces nach C oder object files waeren irgendwie C und H files bzw getrennte object files - export schreibt ins .h file
   bzw exportiert das symbol aus dem object file


Evolution of Lisp, pp 66 ff: Macros nach dem paper von Timothy P. Hart in 1996
pp73ff: modernes defmacro

solange es kein rplaca gibt, koennte man int, float, double und ggf kurze/ lange strings/ symbols in jeweils massgeschneiderte ConsCell stecken
-> muesste sehr hohe speichereinsparung und performanceverbesserung bringen
sollte es rplaca geben, muesste dieses logik haben, um bei typaenderung in ein neues ConsCell umzukopieren und dieses ggf. einzuhaengen
-> oder typaenderungen sind verboten
-> oder man kann optional einen typ angeben, dann ists schnell und der typ ist fix, ohne typangabe ists langsam aber der typ darf sich aendern
z.B. statt
(lambda (a b) (...))
(lambda (integer a double b) (...))
 

nach bytecode compilieren: der bytecode wird dann in einem threaded interpreter abgearbeitet
der interpreter sollte wsl direkt in eval drinstehen wg. TCO. der threaded interpreter kann
direkt cons, car, cdr, +-*/ usw. ist sonst aber sehr aehnlich dem interpreter-eval.
die threaded interpreter "methode" bekommt environment
und ein int (oder char? eher byte[]) array mit bytecode und arbeitet den bytecode ab:
char[] code; XXX env;
int ip = 0;
top:
while (ip < code.length) {
switch (code[ip++]) {
case car: extendenv(...; continue top;
case cons: extendenv(new ConsCell(...; continue top;
}

ggf. auch in den interpreter einige funktionen wie +/- "inlinen"



cache fuer assoc: define/ defun loescht einen allenfalls vorhandenen eintrag.
nicht globaler cache sondern lokale variable in eval, wenn eval mit einem
erweiterten environment endet, ist der nunmehr ungueltige cache auch weg.
ggf nicht hashmap<string,object> sondern arraylist<ConsCell>, eine funktion
wird wohl nur wenige symbole benutzen, da kann linear search schneller sein,
und es werden viel weniger objekte erzeugt.
-> problem: bringt nix bei rekursionen, ausser aufrufe von eval bekommen
   eine kopie des aktuellen cache, aus dem neue lokale variablen/ argumente
   entfernt wurden

zweiter versuch:
topEnv sollte ein Member vom Interpreter sein, damit allfaellige threads, in denen eval laeuft,
dasselbe globale environment haben und ggf erweiterungen sehen
Namensduplikate sind im globalen topEnv verboten, deswegen braeucht man keine reihenfolge, hashmap fuer topenv
wuerd gehen
ein execution environment, d.h. was am parameter env von eval haengt, ist immer einige dynamische Scopes
des executioncontext (parameter, let, ...) aufeinander gestapelt,
drunter ggf. lexical closure, drunter (dynamisches) globales topEnv.
Wenn ein lexical Closure aufgerufen wird, ist das environment (parameter closure topEnv).
Wenn ein dynamic Lambda aufgerufen wird, ist das Environment (parameter aktuelles-dynamisches-environment).
-> bei dynamic Lambda koennen Symbole des aktuellen Env globals verstecken, bei lexical nicht

wenns in einem Scope keine duplikate geben darf, koennte es pro scope einen cache fuers environment geben.
Ist ein parameter von eval so wie env, bei einem neuen executionscope
(einige aber nicht alle rekursiven aufrufe von eval) faengt man mit einer neuen, am einfachsten leeren map an.
der Scope endet beim return von eval, damit ist die hashmap auch weg.
bei einem variablenzugriff wird im cache nachgeschaut, und ggf. das
(symbol . wert) tupel ganz normal gesucht und in den cache gesteckt.





Speicherverwaltung selber machen in Java oder C:

Der Heap ist ein Array int[], 2 aufeinander folgende elemente sind ein cons
allokation ist bump allocation. ist der zaehler == array.length muss das array in ein neues groesseres array umkopiert werden
die ints werden als bitmasks interpretiert:
  die niedgristen 3 bits sind der variablen typ (d.h. 8 typen moeglich)
  intwert >> 3 ist der wert:
    pointer: ein index ins array
    symbol: ein index in die (getrennte) symboltabelle
    number: die zahl
    usw.

statt 3 bits koennten mehr oder weniger verwendet werden, wird die max anzahl cons zells groesser oder kleiner
in C koennten (muessen aber nicht) Pointer wirkliche Pointer statt indizes sein, wuerde eine indirektion sparen,
  diese muessten beim realloc des arrays (i.e. heap vergroessern) aber angepasst werden
optionales GC waer moeglich, in C und in Java, oder man laessts weg fuer kleine programme
generational heaps waeren auch moeglich, dann muesste es verschiedene pointertypen geben, jeder typ zeigt in einen anderen heap
das ergebnis einer expression koennte aus dem Heap (der auch garbage enthaelt) rausextrahiert werden, indem man wie ein GC dem root folgt,
  das ergebnis ist dann ein array das kleiner ist als der heap, also der GC komprimierte Heap

das waer alles in einer Klasse Heap { cons(); car(); cdr(); } abstrahierbar, nur die klasse kennt ConsCell
-> interface ConsCell waer moeglich. beim ArrayHeap sieht ConsCellImpl so aus:
ConsCellImpl {
    ConsCell(int n);
    Object car() { return get(n); }
    Object cdr() { return get(n+1); }
    Object get(int n) {
        int type = heap[n] & 1<<3;
        int value = heap[n] >> 3;
        switch (type) {
        case integer:
        case pointer: return new Integer(carvalue);
        case symbol: return symtab[carvalue];
        case float: // Float#intBitsToFloat benutzen, vgl NaN trick in Lox
        }
    }
    rplaca(newVal)...
    rplacd(newVal)...
}

ohne variablenzuweisungen braucht man eigentlich keinen gc und kein refcounting, einfach beim return
"alles freigeben, was nicht im returnvalue steckt" ?!?
-> so wirds wohl rust machen, plus borrow checker
-> "alles freigeben, was nicht im returnvalue steckt" ist aber nicht so leicht



backticks und , ggf. auch ,@ im scanner einbauen?
(defun constant-adder (a)
  (eval `(lambda (b) (+ (quote ,a) b))))

einen debugger in eval einbauen? expression fuer expression? und/ oder eine special form break? :break symbol?

derzeit haben closures lexikalische lokale variablen und dynamische globale variablen.
ggf. die globalen variablen
auch beim closen in die closure stecken, nur dann kann die closure ein array werden,
und man kann alle environment zugriffe durch array index zugriffe ersetzen.
parameter sollten dann auch slots im array sein, beim func call entsprechend abfuellen
-> umsetzung: beim closen nicht bei env sondern cdr(env) beginnen. das erste element ist das (null . nil) cons,
   erweiterungen werden dahintergezwickt. kann man per cmdline umswitchen.
   -> leider nein, das environment beim closen ist (lokalesenv globalesenv)

utils: combine, list, nth, nhtcdr, c*r

Hashmaps
-> make-hash-table
   get-hash key -> value

flag ob die identifier auf UC umgestellt werden sollen
flag fuer symbols:
--symbols=uc ... symbole werden beim lesen auf UC umgestellt
--symbols=ci ... symbole werden nicht umgestellt, aber case insensitive verglichen
--symbols=cs ... symbole werden as is verwendet, case sensitive verglichen

bei endcalls koennte man die parameter der aktuellen funktion fuer namensgleiche parameter nutzen: 
nicht alle argumente dranhaengen, sondern entweder dranhaengen oder bei gleichnamigen den alten wert ersetzen
wuerd ggf bei dynamic UND lexical closures was bringen
-> nein nur dynamic, lexical closures erben das environment ja nicht

Vielleicht doch set/setf/setq, vgl ABOUT LISP https://graham.main.nc.us/~bhammel/graham/lisp.html
rplaca, rplacd
Vielleicht ein "Imperative Paket" mit flags ein/ausschalten?

        if(car(exp) == s_define)                        // "define"
          return(extend_top(car(cdr(exp)),
                            eval(car(cdr(cdr(exp))), env)));
        if(car(exp) == s_setb) {                        // "set!"
          obj *pair   = assoc(car(cdr(exp)), env);
          obj *newval = eval(car(cdr(cdr(exp))), env);
          setcdr(pair, newval);
          return newval;
        }

am besten setf weglassen, weil das macht serious magic
-> set ... belegt den ersten gefundenen wert im environment neu. dynamic, lexical, global, halt dort, wos assoc zuerst findet
           beide argumente werden evaluiert
-> setq ... wie set aber das erste argument wird nicht evaluiert
-> rplaca, rpclacd http://clhs.lisp.se/Body/f_rplaca.htm
   rplaca cons object => cons
   rplacd cons object => cons



fehlende schliessende klammer wird IMMER mit der letzten zeile gemeldet
-> oeffnende Zeile merken und ausgeben

format und string-format zusammenziehen:
-> format t <string> schreibt auf stdout, return wert ist <string>
-> format nil <string> schreibt NICHT auf stdout, return wert ist <string>
-> format-locale und string-format-locale detto



Datei IO
(pprint (read (open typ "/Users/ashokkhanna/lisp/test-pprint.lisp"))) ; typ koennte 'utf-8 oder 'ansi oder auch 'url oder 'ftp sein
-> datentyp File
-> funktion (open string...) -> File ; koennte eine menge pathelemente bekommen, setzt die mittels pathsep zusammen vgl NIO
            (close file) -> t
            (read-line file) -> String oder nil
            (read-all-lines file) -> (line...)
bringt aber nur was, wenns auch stringmanipulationsfunktionen gibt
-> string->charlist
-> (split splitchars sting) -> (elements...)

(load 'utf-8 "lispfile.lisp")
-> erster optionale parameter ist ein symbol fuer den Zeichensatz

Stringfunktionen: format kann auch strings zusammensetzen
strings sind eine LSIP sequence, fuer sequence gibts
-> subseq sequence start &optional end => subsequence

(concatenate 'string "all" " " "together" " " "now") =>  "all together now"
(concatenate 'list "ABC" '(d e f) #(1 2 3) #*1011)
=>  (#\A #\B #\C D E F 1 2 3 1 0 1 1)
(concatenate 'list) =>  NIL

CL hat stringp string= string<=, ...

LambdaJString.value von String auf char[] umstellen?
-> wuerde ggf. builtins rund um java.lang.Character erleichtern
-> char ist 16 bit
-> Java11 speichert String.value nicht als char[] sondern byte[], dieses Speicherersparnis waer dann verloren



In einer LISP Datei nach dem Ende einer Toplevel form koennten Daten stehen, die wuerden von read gelesen
-> Beispiel machen
LambdaJ> (write (read)) "Hello, World!"
"Hello, World!"
==> t



script fuer den aufruf
-> default parameter
-> files oeffnen und dann von console lesen





Generic S-Expression reader/ writer: (<n>:<octets>)

read koennte einen optionalen ersten string parameter als filename interpretieren und dieses file lesen
statt lispStdin, write sinngemaess, ggf. format und format-locale

in eval eine lokale variable result einfuehren, das wird vor dem return zugewiesen, dann kann finally den returnwert tracen

primitives fuer Environmentvariables und -D Java Systemproperties. wenns nicht existiert, gibts nil, wenns nicht als
double lesbar ist, gibts NaN
primitives fuer isNan, oder konstanten NaN, Infinity und (eq d NaN)

alles geparste in main merken, und mit :w in eine datei schreiben und/ oder zumindest mot :l auflisten
weitere debug gschichten wie zb :env fuer environment auflisten

builtin oder special form fuer try/catch:
try = (lambda (func catch-handler finally) (
  try { return func(); }
  catch (Exception e) { return catch-handler(e); }
  finally { finally(); }
)





cadr, caddr, cadar, cddr, ... in eval verwenden und schauen, wieviel kleiner eval wird
-> solche primitiven wuerden auch Lisp programme schneller machen weil weniger assoc aufrufe
-> ein optimizer, der in define oder lambda reingezwickt wird, koennte (car (cdr o)) erkennen und durch (cadr o) ersetzen
   mit rekursivem abstieg muesste man nur current node und naechste stufe betrachten
   car/car  -> caar
   car/caar -> caaar
   car/cadr -> caadr
   car/cdr  -> cadr
   car/cdar -> cadar
   car/cddr -> caddr

   cdr/car  -> cdar
   cdr/caar -> cdaar
   cdr/cadr -> cdadr
   cdr/cdr  -> cddr
   cdr/cdar -> cddar
   cdr/cddr -> cdddr

beispiel, wie man einen logger einhaengen kann.

LambdaJError extends RuntimeException   ... abstract
Syntaxerror extends LambdaJError        ... nur eval
RuntimeError extends LambdaJError       ... nur primitives

k.a. wieviel die ConsCell casts bremsen
Alternatives Objectmodell mit weniger casts:

interface Value {
    default car() { throw new Error("not a cons"); }
    default cdr() { throw new Error("not a cons"); }
    String toString();
}

interface Atom extends Value {
    Object value;
    String toString() { return value.toString(); }
}

class ConsCell extends Value {
    Value car, cdr;
}

Value car(Value v) { return v.car(); }
Value cdr(Value v) { return v.cdr(); }
ConsCell cons(Value car, Value cdr) { return new ConsCell(car, cdr); }

nice to have: apply mit zuviel/ zuwenig args fuer ein lambda: ueberschuessige args koennten gemeinsam mit dem letzten als liste uebergeben werden,
fehlende als null.


Doku: ein Custom Parser koennte statt parsen eine Liste liefern (koennte z.B. hardcodiert
mit new ConsCell zusammengestoppelt werden) und intern() koennte mittels String.intern() umgesetzt werden.
Anmerkung: Symbols sind Strings, Stringliterale in der o.a. Liste sind bereits mit String.intern() bearbeitet,
  dazu passt die Umsetzung der Parsermethode intern() mittels String.intern()
Anmerkung 2: Lisp Strings werden als LambdaJString repraesentiert
Anmerkung 3: intern() mit einer HashMap waer auch nicht schwer

Doku: https://en.wikipedia.org/wiki/Peano_axioms enthaelt natuerliche Zahlen basierend auf Mengen,
koennte eine Anleitung sein, wie man Zahlen in einem Lisp ohne Zahlen umsetzen kann
0 = nil
1 = succ(0) = '(0) = '(nil)
2 = succ(1) = '(0 1) = '(nil (nil))
3 = succ(2) = '(0 1 2) = '(nil (nil (nil)))

addition:
(add (a b) (if (null? b) a (add '(nil a) (cdr b))) ; oder so aehnlich

multiplikation:
(mul (a b) (if (null? b) nil (add a (mul a (cdr b)))) ; oder so aehnlich


Clisp:
(setf zero ())                                ; -> zero = NIL

;(define (cons a b) (lambda (f) (f a b)))      ; define?
;(define (car c) (c (lambda (a b) a)))         ; define?
;(define (cdr c) (c (lambda (a b) b)))         ; define?

(defun succ (a) (cons zero a))                ; das geht

(setf one (succ zero))                        ; -> one = (NIL)
(setf two (succ (succ zero)))                 ; -> two = (NIL NIL)
(setf three (succ (succ (succ zero))))        ; -> three = (NIL NIL NIL)
(setf four (succ (succ (succ (succ zero)))))  ; -> four = (NIL NIL NIL NIL)

(defun add (a b) (if (eq b zero)
                     a
                     (add (succ a) (cdr b))))

(defun mul (a b) (if (eq b zero)
                     zero
                     (add a (mul a (cdr b)))))

;(write (add two three)) ; -> (NIL NIL NIL NIL NIL) aka six
;(write (mul four three)) ; -> (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) aka twelve
(write (mul zero three)) ; -> NIL aka zero

(defun true (a b) a)
(defun false (a b) b)
(defun my-if (a b c) (funcall a b c))

;(write (my-if #'false one two)) ; -> (NIL NIL) aka two


;(define and (lambda (p q) (if p q false)))    ; define?
;(define or  (lambda (p q) (if p true  q)))    ; define?



-> "intern" wird bremsen, koennte HashMap oder selber geschnitzte Open Hashing Map sein
   zumindest die Symbole wie lambda, labels,... nicht immer wieder internen, sondern deferred supplier
   -> symbole memoizen ist erledigt
-> der Lookup in env wird bremsen (jmh sagt: assoc braucht 40%), auf HashMap String->ArrayList umstellen ist nicht so trivial, weil
das Environment bei funcall staendig erweitert/ zurueckgesetzt wird (fuer funcall wird das environment erweitert,
dann gehts mit dem urspruenglichen weiter). Vielleicht eine Art Kette von Maps? funcall erzeugt eine neue Map die
einen link zum vorgaenger hat 

Zweiter Versuch:
Das Environment sieht nur der Java Code, duplikate sind verboten. HashMap muesste also doch gehen?!
Zugriff nur mit assoc und extend, extend schmeisst eine Excpeption, falls es das symbol schon gibt.
sogar set! muesste gehen?!
-> nein, geht auch nicht. beim aufruf von funktionen gibts schon duplikate, und nach dem return der funktion
   muss das environment wieder abgeraeumt werden, s.o.





Multithreading waer eigentlich nicht so schwer: solange nix geschrieben werden kann, braucht eigentlich nur die
Symboltable synchronized sein ?!?
-> und das environment?
 
Methoden ConsCell toList(), toArray(), toMap(), iterator(), stream()??? map() flatMap()
-> damit bekommt man Ergebnis-Daten raus am Ende des Lisp Programms
-> Wenn man dem Interpreter eine read Funktion ins Environment mitgibt, bekommt man auch Daten rein (abgesehen vom
Lesen von stdin). So eine read Funktion koennte z.B auch XML oder JSON nach ConsCells parsen
    -> iterator ist erledigt



(char-int C:character): integer expr ; Converts character to integer.
(int-char I:integer): character expr ; Converts integer to character.

The read syntax for characters objects is simple: #\ followed by the desired character. 





http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node149.html
list-length could be implemented as follows:

(defun list-length (x) 
  (do ((n 0 (+ n 2))            ;Counter 
       (fast x (cddr fast))     ;Fast pointer: leaps by 2 
       (slow x (cdr slow)))     ;Slow pointer: leaps by 1 
      (nil) 
    ;; If fast pointer hits the end, return the count. 
    (when (endp fast) (return n)) 
    (when (endp (cdr fast)) (return (+ n 1))) 
    ;; If fast pointer eventually equals slow pointer, 
    ;;  then we must be stuck in a circular list. 
    ;; (A deeper property is the converse: if we are 
    ;;  stuck in a circular list, then eventually the 
    ;;  fast pointer will equal the slow pointer. 
    ;;  That fact justifies this implementation.) 
    (when (and (eq fast slow) (> n 0)) (return nil))))



isNaN, isInfinite, isFinite
-> ggf. parameter "Error bei NaN, Infinity etc."
div, remain, trunc, round, abs
weitere operatoren aus java.lang.Math (oder StrictMath?)

irgendwie fliessen eval und apply ineinander. apply kann man mit eval implementieren, und umgekehrt?!



Vielleicht car, cdr, cons, ConsCell in eine Basisklasse LambdaJRuntime rausziehen?
LambdaJ koennte man als Lisp Programm sehen, das von Hand nach Java uebersetzt wurde,
und ein Lisp Programm verwendet Lisp Runtime wie car, cdr, ... .
Falls ein LambaJ Compiler kommt, wuerden erzeugte Java Programme dieselbe Runtime verwenden.
Fuer interpretierte Programme gibts die Builtin-Wrapper, die Parameter-Checks machen und
die Argument-Liste in Argumente wandeln.
-> public static nested class LambdaJRuntime + "import static LambdaJ.*"
   damit gaebs nur wenig Aenderungen in LambdaJ, und externer Code haette auch Zugriff mittels "import static LambdaJ.*" 

Falls Compiler, sollte der nicht nur ein Programm sondern z.B. *.lisp uebersetzen,
ggf. mit timestampcheck



(loop for thing in list
   do (if (numberp thing)
          (format nil “I’m a number: ~a~%” thing)
          (format nil “Not a number!~%”)

(defun factorial(x)
  (reduce '* (loop for a from x downto 1 collect a)))



(write (((lambda () (lambda () (quote (1 2 3))))))) ; geht nur in scheme siehe apply.lisp





JDBC vielleicht objectorientiert anbinden?
funktion nativequery bekommt eine datasource, einen SQL string und eine Liste mit (parameternameatom . wertexpression) tupeln

nativeinsert koennte fuer batchinserts eine Liste von listen mit (parameternameatom . wertexpression) tupeln bekommen und eine liste 
mit ints liefern (ein int für jede insert-tupel-liste)





Doch (noch) nicht:
==========================================

builder pattern:
withStdin(...)        // entweder einen char supplier oder einen ObjectReader
withStdout(...)       // entweder einen String consumer oder einen ObjectWriter
withCustomEnv(...)    // Parameter ist ein Supplier<ConsCell>, der erzeugt eine Liste mit (symbol . builtin)
                      // und wird in der Init Phase aufgerufen
withTrace(Tracer)     // z.B. System.err::println
withTty()             // Shortcut/ convenience: benutzt System in/out/err, kein Custom Env
obige methoden liefern ein Interface "LambdaJBuilder" OHNE interpret aber mit build()
build()               // bastelt alles zusammen und liefert ein Interface "LambdaJ" mit interpret(), withStdin(), withStdout()
interpret(...)        // entweder einen char supplier oder einen Parser, oder ein String?!

eine map builtinfunc->name damit printObj die funktionsnamen ausgeben kann?
zweite map fuer FFI funktionen s.u.?

Wenn ConsCell geeignet annotiert ist, sollte jaxb dann XML nach Lists parsen koennen? XML schreiben muesste supereinfach sein?!
-> es braucht viele annotations und public noarg constructors, zawos brauchma des

lisp write liefert als ergebnis den parameter
-> LambdaJ liefert (quote t)

Lambda erweitern, sodass es implizites currying wie in Lambda Calculus unterstuetzt wird?
vgl. https://old.reddit.com/r/learnlisp/comments/izq5fs/how_to_implement_basic_lambda_calculus_operators/g6kikqp/
(define xyzzy (lambda (a b c) (+ a b c)))
(xyzzy 1 2) ; liefert einen fehler, koennte aber ein closure mit a und b und code: (lambda (c) (+ a b c)) liefern

-> makeArgList muesste als ergebnis eine Liste mit 2 Listen liefern: das extenv mit den arguments + liste mit verbleibenden params
   -> wenns keine verbleibenden params gibt, wird die funktion ausgeführt, gibts verbleibende args,
      ist der returnwert ein lambda mit den verbleibenden params. 
-> nur sinnvoll bei lexical closures, weil sonst gingen ja die bereits gesetzten argumente verschuett 

  -> erst mal nicht, currying/ variadic functions, default arguments passen schlecht zusammen

continuations: loops gibts ja keine, ist eine continuation einfach der restliche parse tree? 
ist currentcc cdr(exp) (und das env bzw. closure) ?
-> es koennte eine special form current-continuation geben, angelehnt an lambda, current-continuation haette eine parameterliste,
   aber keinen stmt body. ergebnis von (current-continuation (a b c)) waere ein lambda (lambda (a b c) ...), ... steht fuer
   jene automatisch eingefuegten stmts, die auf den aufruf von current-continuation folgen. d.h. wenn jemand dieses lambda aufruft,
   gehts mit den stmts weiter, und die symbole a b c sind mit werten belegt im environment (d.h. closure) vorhanden.
   -> geht zunaechst aber nur innerhalb einer flachen liste stmts eines lambdas, nicht z.b. innerhalb des true zweigs einer if-clause.
      -> damit das auch geht, muesste man die stmts die der gesamten if clause folgen, auch ans lambda dranhaengen
         -> das waer moeglich, wenn man bei jedem rekursiven oder tailrekursiven aufruf von eval eine verkette liste mit cdr(exp)
            als parameter mitgibt, bei jedem aufruf wird die liste eins laenger. um dann das continuation lambda zu basteln,
            haengt man diese stmt liste an eine kopie von cdr(exp) dran. haette z.b. zur folge: wenn nur im true zweig call/cc
            aufgerufen wird, dann sind die parameter nach der if clause bei durchlauf durch true zweig vorhanden,
            beim durchlaufen des false zweigs nicht vorhanden.
         -> Aufrufe einer Continuation sind effektiv Endcalls
            Nein, sind sie nicht, wenn die gerufene Continuation einfach endet, entspricht das einem return.
            CPS waer ggf. moeglich und nicht so schwer?!?

print/ pprint/ princ/
-> die setzen parameter und rufen write, write kennt viele parameter zur formatierung, siehe
   http://www.lispworks.com/documentation/HyperSpec/Body/f_wr_pr.htm

Environment variable fuer default options
-> aufrufscript stattdessen

sollte format write aufrufen statt direkt zum lispwriter zu schreiben? write koennte erweitert werden, dass es *print-pretty* usw.
auswertet
-> nein, format ruft #printString, write ruft #printObj, format schreibt, was der user im formatstring spezifiziert
   write schreibt entsprechend allfaelliger globalen variablen/ argumenten





Erledigt:
==========================================

welches ergebnis liefert lambda mit einer liste als body?
-> sollte ergebnis der letzten form sein

Klasse Builtin statt UnaryOperator<Pair> einfuehren

eq vergleicht identitaet, was macht Lisp? https://stackoverflow.com/questions/547436/whats-the-difference-between-eq-eql-equal-and-equalp-in-common-lisp
-> checken ob das passt, z.b. (eq (cons (quote 1) (quote 2)) (cons (quote 1) (quote 2))) ist nicht identisch aber gleich (?)
-> GNU CLISP v2.49+ liefert NIL

Eine JUnit funktion, die liest alle lisp files aus einem verzeichnis und führt sie aus.
erwartetes Ergebnis bzw. fehlermeldung steht in der datei in einem kommentar drin, z.B.
; result:(1 . 2)
oder
; error-prefix: SyntaxError in line 12:
und ggf.
; output: Hallo Welt

Lambda -> LambdaJ

Vielleicht in printObj umlenken:
(quote t) -> "t"
null -> "nil"

beim scannen zeile und spalte mitzaehlen und in fehlermeldung einbauen

apply fuer lambdas, siehe apply.lisp

verschiedene konstruktoren fuer Pair und ueberladene cons brauchts wahrscheinlich nicht, cons(Object,Object) muesste reichen

builtin write-line
-> common lisp hat das, parameter muss aber ein string sein

Datentyp double, (nicht int) unterstuetzen

eq fuer number korrigieren
-> oder eq lassen und = einfuehren, achtung beim vergleichen von double!
-> vielleicht = mit optionalem drittem double parameter fuzz fuer die genauigkeit

+ - * / %, factorial beispiel

car, cdr umstellen dass sie Object uebernehmen
-> dann gibts einen cast in car/cdr statt 1000 casts ueberall

vielleicht "Object car(Object)" und "Pair pcar(Object)"?
-> Eruebrigt sich ggf. durch Umstellen von car(Pair) nach car(Object) 

die parameterchecks ignorieren zuviele argumente

numberp, ggf. atom korrigieren
symbol? vs atom vs numberp

<, >, usw checken ob Double#compareTo Vorteile bzgl. NaN und +- 0.0 hat, derzeit passiert Unboxing

tests fuer atom, consp, listp, symbolp, numberp

test fuer eval nil und eval t, ggf. symbol t einfuehren

tests und fehlertests fuer number und operatoren

numberp() ggf. teilweise durch atom() ersetzen, dann koennen externe Builtins ihre eigenen Datentypen
in car reinstecken, der Interpreter sieht und verarbeitet nur Object

errortests fuer lambda/ builtin mit zuviel/ zuwenig parametern aufrufen

errortests fuer fehler wie erster parameter fuer lambda ist keine symbolliste

Sollen die interpret...() Methoden einen String oder ein Objekt zurueckgeben?
Vielleicht Object zurueck, und ConsCell bekommt eine toString() Methode basierend auf printObj?

Scanner/Parser in eine Klasse rausziehen, je ein Objekt ProgramParser und InputDataParser,
die Lisp Funktion read verwendet den InputDataParser.
Symboltabelle zu geeigneten Zeitpunkten auf null setzen, wahrscheinlich im Konstruktor der ScannerParserKlasse

if(!strcmp(token, "\'")) return cons(quote, cons(readobj(), nil));

isParen und isQuote nach isSyntax zusammenziehen



Tail recursion erkennen: es wird eine Funktion aufgerufen, die im environment 1 hoeher ist (?)
oder wenigstens loop einbauen
-> einfacher ists alle tailcalls zu optimieren

eval hat einige endrekursive aufrufe. koennte man eliminieren.
vielleicht noch einen zweiten levelzaehler einfuehren, dann kann man den level fuer eval und (kleinere) rekursionstiefe anzeigen

eigentlich passiert die rekursion ja in eval:
evlis, evcon & co inline expandieren, und das letzte listenelement nicht mit rekursion aufrufen sondern
manuell tail recursion elimination machen.

PROBLEM: function calls haben ein geaendertes environment extenv
-> einen stack aus extenvs aufbauen: ein int "stackarray" in dem merkt man sich, wieviele elemente vorne
drangepickt wurden und nach verarbeiten des calls entfernt werden müssen 

dann werden nicht nur tail rekursionen wegoptimiert, sondern alle tail calls. es ruft zwar die eine Lisp funktion
eine andere auf, aber in wirklichkeit laeuft nur der code der einzigen Java-methode eval. 



eval, evlis, evcon vielleicht in haendischem CPS?!?
-> eruebrigt sich durch TCO

Erkennung von zirkulaeren Listen koennte man in printObj einbauen
-> aber ohne set gibts derzeit eh keine zirkulaeren Listen ?!?)
-> contains self aber schon

printObj auf loop umbauen, "sich selbst enthalten erkennen", vgl collection.toString()

"t" aus/ einschaltbar machen: flag "HAVE_TRUE"
-> falls true  -> t in der symbol table und _expTrue = t
-> falls false -> t nicht in der symbol table und _expTrue = (quote t)

Numbersupport mit flags ausschalten?
Optional BigDecimal statt Double?

fnull, fcons usw brauchen keine members zu sein, koennten lokale variablen in environment() sein
-> vorher environment() aufteilen?

der Double Support ist eigentlich nur mittels Builtins umgesetzt
-> in ein eigenes ExtEnv verpacken, damit kann mans optional machen,
   oder alternativ/ zusaetzlich z.B. BigDecimal unterstuetzen
-> UND im Lexer gibts Support fuer Double

--help

Datentyp Strings unterstuetzen
-> laenger als SYMBOL_MAX=32

Strings und Characters braucht eigentlich nur der Scanner, Parser (readObj) und Builtin Funktionen (inkl printObj!!!) kennen.
Strings, Chars und Symbols sind alles Atoms, aber nur Symbols sind in der Symboltable

Parser refactoren:
LispParser bekommt statt InputStream einen IntProducer:
fuer InputStream in:
    () -> in::read
oder fuer StringReader s:
    () ->  s::read

readObj umbauen dass (a . b) eingelesen werden kann?

Builtins sollten ggf. expression mitbekommen fuer ausgabe von fehlermeldungen

printObj sollte symbols mit syntax als |xxx| printen. Was syntax characters sind, weiss nur der Parser
-> printObj als Methode von Parser, naechsten punkt umsetzen!

Builtins sollten ggf. parser (symboltabelle) und ggf. environment mitbekommen, dann koennten sie static sein,
waer ggf. besser fuer custom builtins
-> builtins mit env koennten late binding machen
-> builtins muessen printObj des parsers verwenden
-> environment() koennte static sein

!!!!!!! Alles falsch: Syntax characters bestimmt der ObjectWriter.
Builtins sollten Symboltabelle, ObjectReader in, ObjectWriter out, ggf. Tracer, ggf. Environment bekommen

write sollte ObjectWriter.printObj() verwenden,
zum Tracen weiterhin das statische printObj verwenden
-> LispParser (eigentlich ObjectWriter, s.u.) bekommt methode printObj, bisherige statische Methode printObj in traceObj umbenennen oder printSExpression 
-> write schreibt im gewuenschten Format, Errormessages sind im Format S-expression
-> Syntax characters von S-expressions als static Konstante von LambdaJ rausziehen,
   dann kanns Lispparser und das statische printObj verwenden



getrennter Reader fuer read
-> Object interpret(Supplier lispSource, Supplier lispStdin, Consumer lispStdout, Supplier<ConsCell> customEnvironment)
-> oder LambdaJ in Builder Pattern umbauen:

interface ObjectReader { Object readObj(); }
interface SymbolTable { String intern(); }
interface Parser extends ObjectReader, SymbolTable

interface ObjectWriter { String printObj(Object o, boolean headOfList, boolean eol); }
class LispParser implements Parser, ObjectWriter

interface Tracer { void println(String); }

FFI: eine special form "extlabels". funktioniert aehnlich wie labels,
aber statt funktionsdefinitionen gibt man einen Klassennamen an (und vielleicht ein zusaetzliches optionales namenspraefix,
damit man im falle von gleichnamige methoden in zwei klassen "namespaces" zum trennen verwenden kann), und
von dieser klasse werden alle public methoden mit der Signatur UnaryOperator<Pair> ins Environment gesteckt.
Oder statt reflection: "extlabels" bekommt den Namen einer statischen methode die liefert eine Map Funktionsname->UnaryOperator<Pair>

Oder: LambdaJ bekommt eine Methode void registerBuiltin(String funcName, Builtin javaFunc), die pickt eine neue
Funktion ans Environment vorne dran.
Oder: zus. Parameter ConsCell extEnv, damit kann man eine Liste mit zusaetzlichen Builtins mitgeben



primitive string-format-localized: erster parameter ist locale, z.B.
(format-string-localized "en-US" "%g" 1)

evlis/ evcond sollten auch was tracen. stackanzeige erhoehen, evallevel nicht
einrueckung basiert auf javastackzaehler, anzahl sterndaln evallevel - javastackzaehler

apply erlaubt nur 2 argumente, sollte aber 2+ akzeptieren (und gegen parameterliste checken?)
siehe apply3.lisp
laut http://www.n-a-n-o.com/lisp/cmucl-tutorials/LISP-tutorial-20.html:
(apply #'+ 3 4 '(3 4))
Apply is just like funcall, except that its final argument should be a list; the elements of that list are treated
as if they were additional arguments to a funcall.
-> apply ist komplett hinueber

(write " ") schreibt " " inkusive der double quotes
-> vielleicht write-string und write-line

Escapig von " ", ', \ ...
SExpWriter sollte so schreiben wie SExpReader liest, d.h. mit escaping
ConsCell.toString() sollte nicht escapen
todo gelesen wird ein Symbol he\(lo, geschrieben wird |he(lo|

Wenn eine Funktion labels oder cond enthaelt, werden tailcalls effektiv nicht wegoptimiert, weil evlabels bzw. evcond
auf den Java stack kommt. "if" ist in eval inline drin, deswegen funktioniert TCO trotz "if".

environment umsortieren

eval braucht keine elsif Kette sein: in jedem if gibts return oder continue

applyPrimitive (2x) in eval in ein try/catch wrappen, im catch:
throw new LambdaJError(e.getMessage + expError(exp))
-> damit sieht man in welcher expression z.B. argumente nicht passen

evlabels inlinen und TCO

performance: benchmarken
warum ist das environment eine liste von listen statt eine liste von cons cells

am ende wird stack und nesting getraced falls TRC_EVAL.
-> TRC_STATS statt TRC_EVAL, zusaetzlich walltime, cpu und anzahl ConsCells tracen.

in dbeval die groesse des environment ausgeben. wahrscheinlich waechst das bei rekursion. 

statt dbgEval -> if (trace >= TRC_EVAL) dbgEval
und die if clause aus dbgEval weg

ggf mit :init altes environment vergessen

im main loop: parsen und checken, ob obj.toString = :w oder = :q ist, so koennte man befehle für den REPL ausserhalb Lisp einbauen

lexikalische closures

lexical closures muessten gehen, indem man das env mit dem lambda mitspeichert und beim aufruf des lambda 
nicht das aktuelle env extended sondern das abgespeicherte
-> umsetzen, indem "lambda" nicht ein lambda ins environment steckt sondern "closure" 
   (oder doch ein lambda und die liste enthaelt nicht nur ("lambda" args body) 
   sondern ("lambda" args body closure), mit nullcheck entscheiden, 
   ob lambda oder closure ausgefuehrt wird. und eval() erweitern, dass closure wie lambda verarbeitet wird, 
   aber statt aktuellem env die closure mit args erweitert
-> mit befehlszeilen parameter --dyn umstellen

labels gehen mit lex clos nicht: im closure sind die labels nicht drin

trace auf final int trace umstellen und im Konstruktor belegen

pfx() und sfx() zusammenziehen, werden immer gemeinsam aufgerufen

' ist wsl falsch: sollte alles rekursiv quoten, derzeit machts nur ein einziges (quote...
-> eher ist apply falsch

der code von apply und functioncall ist fast identisch:
-> makeArgs umbauen, dass kein eval gemacht wird
-> apply macht die args mit eval, functioncall mit evlis
-> mit einigen weiteren umbauten kann functioncall nach apply springen
---> oder beide setzen ein neues 

"enter an expression, enter :h for command help or :q to exit"

defun einbauen, weil define alleine ist muehsam
oder doch defun als macro und macros unterstuetzen?
(defmacro defun (sym params body) (define sym (lambda params body)))

statt Xmal boolean HAVE_xxx
-> ein final int features das im Konstruktor von LambdaJ belegt wird
   static final int HAVE_XXX = 1 << 1,2,3,4...
   methoden boolean haveXXX()
   -> den wert fuer features muss man vorher mit | zusammenbasteln
      zur laufzeit sollten die haveXXX methoden (fast) wegoptimiert werden, wenn features final ist

Bespiel Parser liest serialisierte Objekte, intern ist String.intern()

checken ob die string funktionen geeignet ein/ausgeblendet werden

interpreter bekommt eine methode init()
interpret() überladen das kein neuer parser uebergeben wird. damit kann man immer wieder interpret() aufrufen und defines bleiben bestehen

die sSymbol.get() gschichte ist total overengineered, besser das lazy loading ganz weglassen (ausser vielleicht bei exptrue lassen)

ConsCell hat 4 byte platz wg alignment. man koennte ein int mit typ machen statt LambdaJString und instanceof.
CONS=0 PRIM = 1 LAMBDA=2 CLOSURE=3 ATOM=10 SYMBOL=10 STRING=11 CHAR=12 DOUBLE=12
isAtom() { return typ >= ATOM }, dann koennte custom code seine eigenen typen erfinden.
solange die neuen typnummern >= ATOM sind, sieht der interpreter alles als atom
-> geht doch nicht so: das flag wird nicht bei ConsCell gebraucht, sondern bei den values, die als Object car oder cdr gespeichert sind
-> fuer closure genutzt


primitives format und format-locale: erstes bzw. zwei erste args sind strings, schreiben nach lispStdout

        ThreadMXBean threadBean = null;
        long startCpu = 0L;
        long start = 0L;

            threadBean = ManagementFactory.getThreadMXBean();

            if (threadBean != null) {
                startCpu = threadBean.getCurrentThreadCpuTime();
            }
            start = System.nanoTime();

Variable INTERNAL-TIME-UNITS-PER-SECOND
Builtins GET-INTERNAL-REAL-TIME, GET-INTERNAL-RUN-TIME, SLEEP

define/defun

nil in der symboltabelle als Java null ist fishy, weil symbol nil == null false ergibt
deswegen ist auch der hack in eval bei funktionsaufruf notwendig
-> vielleicht reichts doch, im parser umzulegen? aber was ist im modus ohne nil, aber vielleicht ists dann eh kp

bei cond wird nur das erste stmt ausgefuehrt

LambdaJError(String, Object...) + ggf. Stringkonstanten am anfang der Klasse

in setsymtab nur die symbole erstellen, dies laut features geben soll (if have...)

nCells nicht static, statt im Konstruktor in cons und cons3 schreiben

File mit einigen Expressions als sample session herrichten, sample session mit
  java -jar lambdaj.jar < sample-session.lisp > transcript.txt
erzeugen.
-> flag --prompt einbauen, default fuer tty = true, !tty = false
-> eine sample session mit allen sprachmitteln und kommentaren koennte ein ausfuehrbares reference manual sein
-> aber nur, wenn jede eingelesene zeile auch auf den schirm zurueckgeschrieben wird
   -> parameter --echo und --no-echo
   -> echo koennte umgesetzt werden, indem main SExpressionReader ein Lambda uebergibt, das nicht nur liest sondern ggf. alles
      gelesene auch schreibt
   -> --prompt koennte umgesetzt werden, indem main nicht direkt nach stdout schreibt sondern in ein lambda, das schreibt oder nicht
      oder entweder nach --prompt: (s-> System.out.print) oder --no-prompt: (s-> return)

dotted lists werden entweder nicht richtig glesen oder geschrieben
soll:
'(a . b)              ; (A . B)
'(a . (b . (c . d)))  ; (A B C . D)
'(a b c . d)          ; pprint: (A B C . D)
'(a . (b . (c . ()))) ; (A B C)
'(a b c)              ; (A B C)

LambdaJ ist fast ein Subset von CL, Unterschiede zu CL dokumentieren, am besten ein kurzes Manual mit allen Sprachmitteln
und ggf. Unterschieden
oder ein builtin "help": (help) listet alle special forms und builtins nach lispStdout, (help symbol) schreibt eine Beschreibung
zu "symbol" nach stdout

im repl wird zeile/char immer weitergezaehlt

writeln umbauen auf "\n<string> "
-> mit param
--eol=LISP
--eol=C

http://www.lispworks.com/documentation/HyperSpec/Body/f_get_un.htm
get-universal-time <no arguments> => sekunden seit 1.1.1900
get-decoded-time <no arguments> => second, minute, hour, date, month, year, day, daylight-p, zone

progn fuer if und anderes?
-> nach schema lambda und fallthrough. in zip() shortcut einbauen: if paramlist == null && arglist == null return

vielleicht doch ein let? das waer ein lambda, das die uebergebene funktion in ein lambda mit den werten verpackt
  oder eine special form die nur das environment erweitert und dann "env=extenv; continue;"
-> let muss eine fexpr sein, special form oder macro, oder doch nicht? ja, sonst wuerden die variablenlisten ausgefuehrt
-> oder define setzt werte im aktuellen env
-> nur letrec als special form. letrec ist die obermenge von let und let*

letrec so wie labels umbauen, dass allfaellige closures alles andere sehen, nicht nur die vorher deklarierten

let*

named let* und letrec
named let: gibt dem body einen namen, damit er sich rekursiv aufrufen kann. waer leicht moeglich, das in letrec einzubauen (if symbolp(car(arguments)))
(define (number->list n)
  (let loop ((n n)
             (acc '()))
    (if (< n 10)
        (cons n acc)
        (loop (quotient n 10)
              (cons (remainder n 10) acc)))))

muss man bei named let immer alle parameter befuellen?
-> in scheme ja

-> number operatoren auf long erweitern
   div: integer division, rem: rest
   numberp erweitern
   floor, ceil und round

printSEx umbauen, dass es statt stringbuilder einen Consumer<String> uebernimmt, zum schreiben in file

eval wird IMMER mit stack+1/level+1 aufgerufen
-> +1 bei den aufrufen weg, am anfang von eval machen

define und defun sollten ggf das symbol liefern

eval ins environment einhaengen?
-> The main reason for beginners is: you don't need it. https://stackoverflow.com/questions/2571401/why-exactly-is-eval-evil

environment erweitern: statt cons(null, null) -> extenv = append(obj, extenv)

try/ catch für javacode in eval statt in d, weil da kann man in der Fehlermeldung die Expression ausgeben

statt der for (list) schleifen den iterator benutzen, sollte dotted list und circular handeln

der Parser koennte integer auch parsen, ggf. auch char, long, biginteger, bigdecimal mit irgendeinem praefix gekennzeichnet. 
sind alle Number, k.a. ob das beim erweitern der operatoren was bringt
-> in den Operatoren ((Number)x).doubleValue zum Rechnen, ergebnis muss dann ggf. auf den richtigen typ gebracht werden
   / ergibt immer double, bei *+/mod haengt der ergebnistyp von den eingehenden typen ab
-> dann bräuchte man wohl auch typumwandelfunctionen, sonst stellts string-format auf, wenn man nicht mehr weiss was man hat

Long im parser unterstuetzen
-> parser geht, cmdline switches + dok fehlen
statt double number dreht double und long auf/ ab, no long dreht ggf. long ab

topEnv kann ein member sein, nicht immer rumreichen, stack detto, mit bisserl aufwand auch level
-> stack und level bleiben params, das sind eigenschaften der methode eval

http://www.lispworks.com/documentation/HyperSpec/Body/f_dec_un.htm
decode-universal-time universal-time &optional time-zone => second, minute, hour, date, month, year, day, daylight-p, zone

FFI: methoden
Object getValue(String globalSymbol)
Object apply(String func, Object... args)

und/ oder

interface MurmelFunction { Object apply(Object... args); }
MurmelFunction getFunction(String func) {...}
Object         getValue(String globalSymbol)

Java FFI:
JSR-223 (Java scripting API)

https://stackoverflow.com/questions/46611132/how-i-merge-lisp-and-java-or-how-i-run-lisp-code-using-java
Interpreter interpreter = Interpreter.createInstance();
interpreter.eval("(load \"my-lisp-code.lisp\")");

Symbol myFunctionSym =
          defaultPackage.findAccessibleSymbol(
               "MY-FUNCTION");
     Function myFunction =
          myFunctionSym.getSymbolFunction();
Cons list = 
          (Cons) myFunction.execute(
                        Fixnum.getInstance(64),
                        Fixnum.getInstance(64));

trace und features in 2 methoden rausziehen

(cons 'a . 'A) -> (a . a)
-> dokumentiert, kein wirkliches problem, nur kosmetische eher positive auswirkung

buitlin apply-java: erster parameter ist ein string statt symbol, d.h. die expression fuer das erste argument muss einen String liefern,
das ist dann der Name einer Klasse und/ oder statischen Methode. Ggf. auch eine statische Methode,
die ein Function<ConsCell,Object> Javalambda liefert.

Vielleicht operator # fuer Javacalls? # wie in javadoc, oder :: wie in methodenreferenzen (waer cooler, moderner)
-> # hat in CL schon eine Bedeutung, z.B. #\C

(define my-map (:: new java.util.HashMap nil))
(:: "put" "java.util.HashMap" my-map "my key" "my value")
(:: "format" "java.lang.String" nil "%g" 1.0)
erster parameter methodenname, zweiter klassenname, dritter objektreferenz oder nil fuer statische methoden, der rest sind parameter fuer die methode
primitive :: koennte durch eine klasse mit methodencache implementiert werden

oder :: erzeugt ein Primitive-Objekt, das Klasse, und Methode enthaelt und spaeter wie eine normale Lisp Funktion aufgerufen
werden kann (aehnlich wie lambda ein closure erzeugt):
(define make-java-map (:: "new" "java.util.HashMap"))
(define java-put-hash (:: "put" "java.util.HashMap")

(define my-map (make-java-map nil))
(java-put-hash my-map "my key" "my value") ; erstes Argument beim Aufruf von "Java-Methoden" ist immer das Java-Objekt, ggf. nil fuer statische Methoden

symbol vielleicht nicht als String sondern class LambdaJSymbol { char[] symname; }, dafuer LambdaJString weg -> stattdessen java.lang.String
-> murmel muss sonst Java string argumente mit symbol abfuellen und Java return String liefert ein symbol (das es nicht gibt)
-> spart eher speicher

parameterchecks fuer letrec

LambdaJ gibts schon. Ausserdem gibts:
JavaLISP, http://jlambda.com, jlisp, rlisp, ROMALISP
-> umbenamsen:
   Murmel: ich mag das tier, murmeln <->-lispeln, Sprache: Murmel, interpreter: jmurmel
   JUCL: Java Un Common Lisp, uncommon Lisp klingt negativ

Vielleicht doch die Zeilennummer in ConsCell speichern fuer Fehlerausgabe?
vielleicht ein --debug flag, dann allokiert der parser andere ConsCells mit zeilennummern?
und printSEx bekommt einen parameter "lines" damit errorexp objekte mit zeilennummern ausgibt
oder LambdaJError bekommt einen zusaetzlichen parameter errorExp und gibt die errorExp aus mit oder ohne zeilennummern
-> ConsCells mit zeilennummern koennte der parser eigentlich immer erzeugen, code gibts nicht so viel, und die daten
   werden dadurch nicht vergroessert

scanner sollte | fuer symbole koennen
oder keine | schreiben
-> "print-read consistency" (a term given in ANSI CL, 2.3.6, in the context of symbols and packages),
   which refers to the concept of objects being printed in a machine-readable way, so that when the
   printed representation is scanned by the reader, a similar object is produced.

die primitive "list" ist trivial: einfach das argument liefern, das ist die variable "arguments" in eval, und das ist bereits genau
die gewuenschte liste

wenn formale parameter eine dotted list sind, wird auf den letzten parameter eine (moeglicherweise leere) liste mit den restlichen argumenten gebunden
-> variadic function mit zumindest einem parameter, scheme machts so
-> checken was passiert, wenn statt einer parameterliste nur ein symbol steht. das koennte dann eine variadic function sein die 0 oder mehrere args schluckt:
   alle argumente werden in eine (ggf leere) liste verpackt und an das einzige parameter symbol gebunden

define hat varargs, defun nicht


statt intern(new LambdaJSymbol... -> genSym(String...
-> das checkt unique symbols und reserved keywords

reserved words einbauen: vgl. Evolution of Lisp, pp 62 ff
-> NIL may not be used as a function, nor as a variable
-> T may not be used as a variable.

redefinieren der symbole von special forms verbieten? auswirkung hats eh keine.
->
special forms werden nicht im environment gesucht, die verarbeitung ist hardcodiert
die auswirkung davon laesst sich durch folgendes symptom beschreiben:
effektiv sind die symbole von special forms in einem eigenen namespace wo operatoren zuerst gesucht werden
(define eval 1) -> eval
(eval eval) -> 1
(eval 'eval) -> 1
vielleicht zumindest insofern reparieren, dass fuer die keywords symbole angelegt werden, dann gibt define einen fehler
und es gibt keine sonstigen auswirkungen mehr
-> aber let & co lassen das redefinieren trotzdem zu

ueberlegen, was special form und was primitive ist und was in der reserved word liste landet
-> primitives sind symbols im global env, die koennte man in lambda params und let bindings benutzen
   special forms funktionieren nicht als let bindings und muessen in die liste
   sprachelemente wie eq, cons, car, cdr koennte man als primitive umsetzen, oder aus performancegruenden als special form
   -> notwendige special forms plus "wichtige" primitives in die liste plus t und nil

vielleicht doch ein sprachmittel um gezielt dyn od lex closures zu erzeugen
-> vielleicht mit self evaluating symbol dynamic (self evaluating weil dann kann man quote oder nicht, ist egal)

tests fuer dynamic lambda

tests fuer lambda mit mehreren stmts
-> dynamic_lambda.lisp

vielleicht die feature flags nur im repl, sonst file variablen
-> file variablen als kommentare vor anderen syntaxzeichen, gleich im kommentarloop im scanner auswerten, der setzt featureflags
   beim setInput() die featureflags wieder zuruecksetzen
zumindest --lex ausbauen und --dyn -> --X-dyn mit warning (nicht mehr Murmel, auch kein subset)
vielleicht alle sprachflags -X-... und --dyn-> -XX-dyn
